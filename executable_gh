#!/bin/bash

# gh wrapper - Automatically detect AI tools and use bot token attribution via as-a-bot service
# This wrapper intercepts gh CLI calls and exchanges tokens when AI usage is detected
# Uses am-i-ai shared detection library
# See: https://github.com/trieloff/am-i-ai

# Configuration
BROKER_URL="${AS_A_BOT_URL:-https://as-bot-worker.minivelos.workers.dev}"
APP_NAME="as-a-bot"
DEBUG="${GH_AI_DEBUG:-false}"

# Function to print debug messages
debug_log() {
    if [ "$DEBUG" = "true" ]; then
        echo "[DEBUG] $*" >&2
    fi
}

# --- BEGIN BUNDLED am-i-ai ---
# Bundled from am-i-ai v1.1.0
# https://github.com/trieloff/am-i-ai
#
# This code is auto-generated. Do not edit manually.
# To update, run the propagate-updates workflow in am-i-ai.

_ami_debug() {
    if [ "$AMI_DEBUG" = "true" ]; then
        echo "[am-i-ai] $*" >&2
    fi
}
ami_process_contains() {
    local pid=$1
    local pattern=$2

    # Get process command and name
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        # Linux
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}
ami_check_env() {
    local detected=""

    # Claude Code detection
    # Detect via CLAUDECODE or CLAUDE_CODE_ENTRYPOINT env vars
    # ACP mode sets CLAUDECODE=1 without CLAUDE_CODE_ENTRYPOINT
    # CLI/SDK mode sets both CLAUDECODE and CLAUDE_CODE_ENTRYPOINT
    if [ -n "$CLAUDECODE" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ]; then
        detected="$detected claude"
        _ami_debug "Detected Claude via environment variable"
    fi

    # Gemini detection
    if [ -n "$GEMINI_CLI" ]; then
        detected="$detected gemini"
        _ami_debug "Detected Gemini via environment variable"
    fi

    # Qwen detection
    if [ -n "$QWEN_CODE" ]; then
        detected="$detected qwen"
        _ami_debug "Detected Qwen via environment variable"
    fi

    # Cursor detection - use CURSOR_AGENT to avoid false positives in Cursor IDE terminals
    if [ -n "$CURSOR_AGENT" ]; then
        detected="$detected cursor"
        _ami_debug "Detected Cursor via environment variable"
    fi

    # OpenCode detection
    if [ -n "$OPENCODE_AI" ]; then
        detected="$detected opencode"
        _ami_debug "Detected OpenCode via environment variable"
    fi

    # Codex CLI detection
    # Detect via CODEX_CLI env var or CODEX_SANDBOX (set in sandboxed ACP sessions)
    if [ -n "$CODEX_CLI" ] || [ -n "$CODEX_SANDBOX" ]; then
        detected="$detected codex"
        _ami_debug "Detected Codex via environment variable"
    fi

    # Aider detection
    if [ "$OR_APP_NAME" = "Aider" ]; then
        detected="$detected aider"
        _ami_debug "Detected Aider via environment variable"
    fi

    # Zed detection - complex logic to distinguish human from AI
    # Observed patterns:
    # 1. Human via git panel: ZED_ENVIRONMENT + NO terminal vars + SHLVL=1
    # 2. Human via terminal: ZED_ENVIRONMENT + parent is interactive shell (elvish, zsh, bash, fish)
    # 3. Zed's native agent: ZED_ENVIRONMENT + HAS terminal vars + SHLVL>1 + parent NOT interactive shell
    # 4. ACP integrations: Have their own tool markers (handled above)
    #
    # Key insight: If the direct parent process is an interactive shell,
    # the user is typing commands manually, not the Zed agent.
    local term_program_lower
    term_program_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
    if [ -n "$ZED_ENVIRONMENT" ]; then
        if { [ "$term_program_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
            # Has terminal vars and SHLVL>1 - could be agent or human in terminal
            # Check if parent process is an interactive shell (human typing)
            local parent_comm
            parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
            case "$parent_comm" in
                bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                    # Parent is interactive shell - human typing in terminal
                    _ami_debug "Zed detected but parent is interactive shell ($parent_comm) - human typing"
                    ;;
                *)
                    # Parent is not an interactive shell - likely Zed agent
                    detected="$detected zed"
                    _ami_debug "Detected Zed AI agent via environment (parent: $parent_comm)"
                    ;;
            esac
        fi
        # else: Human git panel (SHLVL=1, no terminal vars)
    fi

    # Copilot detection
    if [ "$GITHUB_COPILOT_CLI_MODE" = "true" ]; then
        detected="$detected copilot"
        _ami_debug "Detected Copilot via environment variable"
    fi

    # Droid detection (Factory AI)
    if [ -n "$DROID_CLI" ]; then
        detected="$detected droid"
        _ami_debug "Detected Droid via environment variable"
    fi

    # Amp detection (Sourcegraph)
    if [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ]; then
        detected="$detected amp"
        _ami_debug "Detected Amp via environment variable"
    fi

    # Kimi CLI detection
    if [ -n "$KIMI_CLI" ]; then
        detected="$detected kimi"
        _ami_debug "Detected Kimi CLI via environment variable"
    fi

    # OpenHands detection
    if [ "$OR_APP_NAME" = "OpenHands" ] || [ -n "$OR_SITE_URL" ]; then
        detected="$detected openhands"
        _ami_debug "Detected OpenHands via environment variable"
    fi

    # Goose detection (Block)
    if [ -n "$GOOSE_TERMINAL" ]; then
        detected="$detected goose"
        _ami_debug "Detected Goose via environment variable"
    fi

    # Auggie detection (Augment Code)
    if [ -n "$AUGMENT_API_TOKEN" ]; then
        detected="$detected auggie"
        _ami_debug "Detected Auggie via environment variable"
    fi

    # Cline detection (VS Code extension)
    if [ -n "$CLINE_TASK_ID" ]; then
        detected="$detected cline"
        _ami_debug "Detected Cline via environment variable"
    fi

    # Roo Code detection (VS Code extension)
    if [ -n "$ROO_CODE_TASK_ID" ]; then
        detected="$detected roo"
        _ami_debug "Detected Roo Code via environment variable"
    fi

    # Windsurf/Cascade detection
    if [ -n "$WINDSURF_SESSION" ] || [ "$TERM_PROGRAM" = "windsurf" ]; then
        detected="$detected windsurf"
        _ami_debug "Detected Windsurf via environment variable"
    fi

    echo "$detected"
}
ami_check_ps_tree() {
    local detected=""
    local current_pid=$$
    local max_depth=10
    local depth=0

    _ami_debug "Starting process tree detection from PID $current_pid"

    while [ $depth -lt $max_depth ]; do
        # Get parent PID
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        else
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        fi

        # Check if we've reached the top
        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            _ami_debug "Reached top of process tree at depth $depth"
            break
        fi

        _ami_debug "Checking PID $current_pid at depth $depth"

        # Check for AI tool patterns
        if ami_process_contains "$current_pid" "claude"; then
            detected="$detected claude"
            _ami_debug "Detected Claude in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "gemini"; then
            detected="$detected gemini"
            _ami_debug "Detected Gemini in process tree at depth $depth"
        fi
        # Detect Codex CLI by process name
        if ami_process_contains "$current_pid" "codex"; then
            detected="$detected codex"
            _ami_debug "Detected Codex in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "aider"; then
            detected="$detected aider"
            _ami_debug "Detected Aider in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "qwen"; then
            detected="$detected qwen"
            _ami_debug "Detected Qwen in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "zed"; then
            # Attribute to Zed's native agent when terminal vars ARE set and SHLVL > 1
            # BUT not if parent is an interactive shell (human typing)
            local tp_lower
            tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
            if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
                local parent_comm
                parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
                case "$parent_comm" in
                    bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                        # Parent is interactive shell - human typing
                        _ami_debug "Zed in tree but parent is interactive shell - human typing"
                        ;;
                    *)
                        detected="$detected zed"
                        _ami_debug "Detected Zed AI in process tree at depth $depth"
                        ;;
                esac
            fi
        fi
        if ami_process_contains "$current_pid" "opencode"; then
            detected="$detected opencode"
            _ami_debug "Detected OpenCode in process tree at depth $depth"
        fi
        # Cursor detection - use cursor-agent to avoid false positives in Cursor IDE terminals
        if ami_process_contains "$current_pid" "cursor-agent"; then
            detected="$detected cursor"
            _ami_debug "Detected Cursor in process tree at depth $depth"
        fi
        # Kimi CLI detection - look for kimi in process command
        if ami_process_contains "$current_pid" "kimi"; then
            detected="$detected kimi"
            _ami_debug "Detected Kimi CLI in process tree at depth $depth"
        fi
        # Crush detection - look for crush in process command
        if ami_process_contains "$current_pid" "crush"; then
            detected="$detected crush"
            _ami_debug "Detected Crush in process tree at depth $depth"
        fi
        # Goose detection - look for goose in process command
        if ami_process_contains "$current_pid" "goose"; then
            detected="$detected goose"
            _ami_debug "Detected Goose in process tree at depth $depth"
        fi
        # Auggie detection - look for auggie in process command
        if ami_process_contains "$current_pid" "auggie"; then
            detected="$detected auggie"
            _ami_debug "Detected Auggie in process tree at depth $depth"
        fi
        # Cline detection
        if ami_process_contains "$current_pid" "cline"; then
            detected="$detected cline"
            _ami_debug "Detected Cline in process tree at depth $depth"
        fi
        # Roo Code detection - use word boundary to avoid matching "kangaroo", etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "roo" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "roo"; then
                detected="$detected roo"
                _ami_debug "Detected Roo Code in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "roo" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "roo"; then
                detected="$detected roo"
                _ami_debug "Detected Roo Code in process tree at depth $depth"
            fi
        fi
        # Windsurf detection
        if ami_process_contains "$current_pid" "windsurf"; then
            detected="$detected windsurf"
            _ami_debug "Detected Windsurf in process tree at depth $depth"
        fi
        # Droid detection - use word boundary to avoid matching android-studio, etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        fi

        depth=$((depth + 1))
    done

    echo "$detected"
}
ami_detect() {
    _ami_debug "Starting AI detection"

    # Phase 1: Environment variable detection
    local env_detected
    env_detected=$(ami_check_env)

    # Phase 2: Process tree detection
    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine results and apply priority order
    local all_detected="$env_detected $ps_detected"

    _ami_debug "Environment detected: '$env_detected'"
    _ami_debug "Process tree detected: '$ps_detected'"
    _ami_debug "Combined detected: '$all_detected'"

    # Priority order: Amp > Codex > Aider > Claude > Gemini > Qwen > Droid > OpenCode > Cursor > Copilot > Kimi > OpenHands > Cline > Roo > Windsurf > Crush > Goose > Auggie > Zed
    # Zed is last because it often hosts other AI tools
    # More specific AI tools take precedence over IDE-level tools
    if [[ "$all_detected" =~ "amp" ]]; then
        _ami_debug "Final result: amp"
        echo "amp"
    elif [[ "$all_detected" =~ "codex" ]]; then
        _ami_debug "Final result: codex"
        echo "codex"
    elif [[ "$all_detected" =~ "aider" ]]; then
        _ami_debug "Final result: aider"
        echo "aider"
    elif [[ "$all_detected" =~ "claude" ]]; then
        _ami_debug "Final result: claude"
        echo "claude"
    elif [[ "$all_detected" =~ "gemini" ]]; then
        _ami_debug "Final result: gemini"
        echo "gemini"
    elif [[ "$all_detected" =~ "qwen" ]]; then
        _ami_debug "Final result: qwen"
        echo "qwen"
    elif [[ "$all_detected" =~ "droid" ]]; then
        _ami_debug "Final result: droid"
        echo "droid"
    elif [[ "$all_detected" =~ "opencode" ]]; then
        _ami_debug "Final result: opencode"
        echo "opencode"
    elif [[ "$all_detected" =~ "cursor" ]]; then
        _ami_debug "Final result: cursor"
        echo "cursor"
    elif [[ "$all_detected" =~ "copilot" ]]; then
        _ami_debug "Final result: copilot"
        echo "copilot"
    elif [[ "$all_detected" =~ "kimi" ]]; then
        _ami_debug "Final result: kimi"
        echo "kimi"
    elif [[ "$all_detected" =~ "openhands" ]]; then
        _ami_debug "Final result: openhands"
        echo "openhands"
    elif [[ "$all_detected" =~ "cline" ]]; then
        _ami_debug "Final result: cline"
        echo "cline"
    elif [[ "$all_detected" =~ "roo" ]]; then
        _ami_debug "Final result: roo"
        echo "roo"
    elif [[ "$all_detected" =~ "windsurf" ]]; then
        _ami_debug "Final result: windsurf"
        echo "windsurf"
    elif [[ "$all_detected" =~ "crush" ]]; then
        _ami_debug "Final result: crush"
        echo "crush"
    elif [[ "$all_detected" =~ "goose" ]]; then
        _ami_debug "Final result: goose"
        echo "goose"
    elif [[ "$all_detected" =~ "auggie" ]]; then
        _ami_debug "Final result: auggie"
        echo "auggie"
    elif [[ "$all_detected" =~ "zed" ]]; then
        _ami_debug "Final result: zed"
        echo "zed"
    else
        _ami_debug "Final result: none"
        echo "none"
    fi
}
ami_is_ai() {
    local result
    result=$(ami_detect)
    [ "$result" != "none" ]
}
ami_detect_all() {
    local env_detected
    env_detected=$(ami_check_env)

    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine and deduplicate
    local all_detected="$env_detected $ps_detected"

    # Remove leading/trailing spaces and deduplicate
    echo "$all_detected" | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//'
}
ami_get_email() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "noreply@anthropic.com" ;;
        "gemini")   echo "noreply@google.com" ;;
        "codex")    echo "noreply@openai.com" ;;
        "aider")    echo "aider@aider.chat" ;;
        "qwen")     echo "noreply@alibaba.com" ;;
        "cursor")   echo "cursoragent@cursor.com" ;;
        "opencode") echo "noreply@opencode.ai" ;;
        "zed")      echo "noreply@zed.dev" ;;
        "copilot")  echo "copilot@github.com" ;;
        "droid")    echo "droid@factory.ai" ;;
        "amp")      echo "noreply@sourcegraph.com" ;;
        "kimi")     echo "noreply@kimi.com" ;;
        "openhands") echo "openhands@all-hands.dev" ;;
        "crush")    echo "crush@charm.land" ;;
        "goose")    echo "goose@opensource.block.xyz" ;;
        "auggie")   echo "noreply@augmentcode.com" ;;
        "cline")    echo "cline@cline.bot" ;;
        "roo")      echo "roo@roocode.dev" ;;
        "windsurf") echo "cascade@codeium.com" ;;
        *)          echo "" ;;
    esac
}
ami_get_name() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "Claude Code" ;;
        "gemini")   echo "Gemini" ;;
        "codex")    echo "Codex CLI" ;;
        "aider")    echo "Aider" ;;
        "qwen")     echo "Qwen Code" ;;
        "cursor")   echo "Cursor AI" ;;
        "opencode") echo "opencode AI" ;;
        "zed")      echo "Zed AI" ;;
        "copilot")  echo "GitHub Copilot" ;;
        "droid")    echo "Droid" ;;
        "amp")      echo "Amp" ;;
        "kimi")     echo "Kimi CLI" ;;
        "openhands") echo "OpenHands" ;;
        "crush")    echo "Crush" ;;
        "goose")    echo "Goose User" ;;
        "auggie")   echo "Augment Code" ;;
        "cline")    echo "Cline" ;;
        "roo")      echo "Roo Code" ;;
        "windsurf") echo "Windsurf Cascade" ;;
        *)          echo "" ;;
    esac
}

# Function aliases for backward compatibility
process_contains() { ami_process_contains "$@"; }
check_env_vars() { ami_check_env; }
check_ps_tree() { ami_check_ps_tree; }
detect_ai_tool() { ami_detect; }
# --- END BUNDLED am-i-ai ---

# Function to find the real gh executable
find_real_gh() {
    # Common locations for gh
    local gh_paths=(
        "/usr/bin/gh"
        "/usr/local/bin/gh"
        "/opt/homebrew/bin/gh"
        "/opt/local/bin/gh"
        "/home/linuxbrew/.linuxbrew/bin/gh"
        "/snap/bin/gh"
    )

    for gh_path in "${gh_paths[@]}"; do
        if [ -x "$gh_path" ]; then
            echo "$gh_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        # Skip our own directory to avoid infinite recursion
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/gh" ]; then
            echo "$dir/gh"
            return
        fi
    done

    echo "gh not found" >&2
    exit 1
}

# Function to parse --repo flag from command arguments
parse_repo_flag() {
    local args=("$@")
    local i=0
    
    while [ $i -lt ${#args[@]} ]; do
        case "${args[i]}" in
            --repo)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
            --repo=*)
                echo "${args[i]#--repo=}"
                return 0
                ;;
            -R)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
        esac
        i=$((i + 1))
    done
    
    return 1
}

# Function to check if operation is safe (read-only)
is_safe_operation() {
    local cmd="$1"
    local subcommand="$2"
    
    case "$cmd" in
        help|--help|-h|version|--version)
            return 0
            ;;
        auth)
            case "$subcommand" in
                status|login|logout|refresh|setup-git|token)
                    return 0
                    ;;
            esac
            ;;
        repo)
            case "$subcommand" in
                view|list|clone|fork)
                    return 0
                    ;;
            esac
            ;;
        pr)
            case "$subcommand" in
                view|list|diff|checks)
                    return 0
                    ;;
            esac
            ;;
        issue)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        release)
            case "$subcommand" in
                view|list|download)
                    return 0
                    ;;
            esac
            ;;
        run)
            case "$subcommand" in
                view|list|watch)
                    return 0
                    ;;
            esac
            ;;
        workflow)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        api)
            # API calls with GET method only
            if [[ "$*" =~ --method[[:space:]]+GET|^GET[[:space:]] ]] || [[ ! "$*" =~ --method ]]; then
                # Default API calls are GET, but be conservative
                case "$subcommand" in
                    user|users/*|rate_limit|repos/*/|orgs/*)
                        return 0
                        ;;
                esac
            fi
            ;;
    esac
    
    return 1
}

# Function to get current repository info
get_repo_info() {
    local repo_spec="$1"  # Optional: explicit repo specification
    local name_with_owner
    
    if [ -n "$repo_spec" ]; then
        # Use explicit repo specification
        debug_log "Using explicit repo specification: $repo_spec"
        name_with_owner="$repo_spec"
    else
        # Try to get repo info from current directory using gh
        debug_log "Attempting to get repo info from current directory"
        name_with_owner=$("$GH_BIN" repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null)
        
        if [ -z "$name_with_owner" ] || [ "$name_with_owner" = "null" ]; then
            debug_log "No repository found in current directory"
            return 1
        fi
    fi
    
    debug_log "Found repository: $name_with_owner"
    
    # Split owner/repo
    if [[ "$name_with_owner" =~ ^([^/]+)/(.+)$ ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        echo "$owner" "$repo"
        debug_log "Parsed owner: $owner, repo: $repo"
        return 0
    fi
    
    debug_log "Could not parse owner/repo from: $name_with_owner"
    return 1
}

# Function to check if a repo should be ignored
should_ignore_repo() {
    local owner=$1
    local repo=$2
    local config_file="$HOME/.config/ai-aligned-gh/ignorerepos"
    
    debug_log "Looking for ignore file at: $config_file"
    
    # If config file doesn't exist, don't ignore
    if [ ! -f "$config_file" ]; then
        debug_log "Ignore file not found"
        return 1
    fi
    
    debug_log "Found ignore file, checking patterns"
    
    # Check each pattern in the ignore file
    while IFS= read -r pattern || [ -n "$pattern" ]; do
        # Skip empty lines and comments
        if [[ -z "$pattern" ]] || [[ "$pattern" =~ ^[[:space:]]*# ]]; then
            continue
        fi
        
        # Trim whitespace
        pattern=$(echo "$pattern" | xargs)
        
        debug_log "Checking pattern: '$pattern' against '$owner/$repo'"
        
        # Check if pattern matches owner/repo exactly
        if [[ "$owner/$repo" == "$pattern" ]]; then
            debug_log "Repository $owner/$repo matches ignore pattern: $pattern"
            return 0
        fi
        
        # Check if pattern is owner/* (matches all repos in org)
        if [[ "$pattern" == *"/*" ]] && [[ "$owner" == "${pattern%/*}" ]]; then
            debug_log "Repository $owner/$repo matches org pattern: $pattern"
            return 0
        fi
    done < "$config_file"
    
    return 1
}

# Function to start device flow authentication
start_device_flow() {
    local scopes="${1:-repo}"
    
    debug_log "Starting device flow authentication with scopes: $scopes"
    
    local response
    response=$(curl -sS -X POST "${BROKER_URL}/user-token/start" \
        -H "Content-Type: application/json" \
        -d "{\"scopes\":\"${scopes}\"}" 2>/dev/null)
    
    if [ -z "$response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    echo "$response"
    return 0
}

# Function to poll for device flow token in background
poll_for_token_background() {
    local device_code=$1
    local state_file=$2
    local interval=${3:-5}
    local max_time=${4:-300}  # Max 5 minutes by default
    
    local start_time
    start_time=$(date +%s)
    
    while true; do
        local current_time
        current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [ "$elapsed" -gt "$max_time" ]; then
            echo "expired" > "${state_file}.status"
            break
        fi
        
        local response
        response=$(curl -sS -X POST "${BROKER_URL}/user-token/poll" \
            -H "Content-Type: application/json" \
            -d "{\"device_code\":\"${device_code}\"}" 2>/dev/null)
        
        local access_token
        access_token=$(echo "$response" | jq -r '.access_token' 2>/dev/null)
        
        if [ -n "$access_token" ] && [ "$access_token" != "null" ]; then
            # Save the token to cache
            echo "$access_token" > "$HOME/.cache/ai-aligned-gh/token"
            chmod 600 "$HOME/.cache/ai-aligned-gh/token"
            echo "completed" > "${state_file}.status"
            rm -f "$state_file"
            break
        fi
        
        local error
        error=$(echo "$response" | jq -r '.error' 2>/dev/null)
        
        if [ "$error" = "authorization_pending" ] || [ "$error" = "server_error" ]; then
            sleep "$interval"
        elif [ "$error" = "slow_down" ]; then
            interval=$((interval + 5))
            sleep "$interval"
        elif [ -n "$error" ] && [ "$error" != "null" ]; then
            echo "failed: $error" > "${state_file}.status"
            break
        fi
    done
}

# Function to get or create cached token
get_cached_token() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local state_dir="$HOME/.config/ai-aligned-gh/auth"
    local cache_file="$cache_dir/token"
    local state_file="$state_dir/device_flow.json"
    
    # Create directories if they don't exist
    mkdir -p "$cache_dir" "$state_dir"
    
    # Check if cached token exists and is still valid
    if [ -f "$cache_file" ]; then
        local cached_token
        cached_token=$(cat "$cache_file")
        
        # Verify token is still valid and check its type
        local rate_limit
        
        if GH_TOKEN="$cached_token" "$GH_BIN" api user >/dev/null 2>&1; then
            # Check if this is a user-to-server token (ghu_ prefix)
            if [[ "$cached_token" == ghu_* ]]; then
                debug_log "Using valid user-to-server token (ghu_ prefix)"
                
                # Optionally check rate limit to confirm it's a proper GitHub App token
                if [ "$DEBUG" = "true" ]; then
                    rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)
                    debug_log "Token rate limit: $rate_limit (15000=GitHub App user token, 5000=OAuth token)"
                fi
            else
                debug_log "WARNING: Token doesn't have ghu_ prefix, may not have app attribution"
            fi
            
            echo "$cached_token"
            return 0
        else
            debug_log "Cached token is invalid, removing it"
            rm -f "$cache_file"
        fi
    fi
    
    # Check if there's an in-progress device flow
    if [ -f "$state_file" ]; then
        local state_age=$(($(date +%s) - $(stat -f %m "$state_file" 2>/dev/null || stat -c %Y "$state_file" 2>/dev/null)))
        
        # If state file is less than 15 minutes old
        if [ $state_age -lt 900 ]; then
            debug_log "Found recent device flow state (${state_age}s old)"
            
            # Check if there's a status file indicating completion
            if [ -f "${state_file}.status" ]; then
                local status
                status=$(cat "${state_file}.status")
                
                if [ "$status" = "completed" ]; then
                    # Token should have been saved, try again
                    rm -f "${state_file}.status"
                    if [ -f "$cache_file" ]; then
                        cached_token=$(cat "$cache_file")
                        echo "$cached_token"
                        return 0
                    fi
                elif [[ "$status" == "failed:"* ]]; then
                    echo "[ERROR] Previous authentication failed: ${status#failed: }" >&2
                    rm -f "$state_file" "${state_file}.status"
                elif [ "$status" = "expired" ]; then
                    echo "[ERROR] Previous authentication expired" >&2
                    rm -f "$state_file" "${state_file}.status"
                fi
            else
                # Still in progress, show the existing code
                local user_code verification_uri
                user_code=$(jq -r '.user_code' "$state_file" 2>/dev/null)
                verification_uri=$(jq -r '.verification_uri' "$state_file" 2>/dev/null)
                
                if [ -n "$user_code" ] && [ -n "$verification_uri" ]; then
                    echo "" >&2
                    echo "=================================================================" >&2
                    echo "  GitHub App Authentication Already In Progress" >&2
                    echo "=================================================================" >&2
                    echo "" >&2
                    echo "  AI tool detected: $AI_TOOL" >&2
                    echo "" >&2
                    echo "  Please complete the authorization:" >&2
                    echo "" >&2
                    echo "  For humans:" >&2
                    echo "  1. Visit: $verification_uri" >&2
                    echo "  2. Enter code: $user_code" >&2
                    echo "" >&2
                    echo "  For AI agents - run these commands:" >&2
                    echo "  echo '$user_code' | pbcopy" >&2
                    echo "  open '$verification_uri'" >&2
                    echo "" >&2
                    echo "  Authentication will complete in the background." >&2
                    echo "  Try your command again in a few seconds." >&2
                    echo "" >&2
                    return 1
                fi
            fi
        else
            debug_log "Device flow state is too old (${state_age}s), removing"
            rm -f "$state_file" "${state_file}.status"
        fi
    fi
    
    # No valid cached token or in-progress flow, start new auth flow
    debug_log "Starting new authentication flow"
    
    # Use device flow for CLI (doesn't require browser redirect)
    debug_log "Starting device flow for CLI authentication"
    flow_response=$(start_device_flow "")
    
    if [ -z "$flow_response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    local device_code user_code verification_uri expires_in interval
    device_code=$(echo "$flow_response" | jq -r '.device_code' 2>/dev/null)
    user_code=$(echo "$flow_response" | jq -r '.user_code' 2>/dev/null)
    verification_uri=$(echo "$flow_response" | jq -r '.verification_uri' 2>/dev/null)
    expires_in=$(echo "$flow_response" | jq -r '.expires_in' 2>/dev/null)
    interval=$(echo "$flow_response" | jq -r '.interval' 2>/dev/null)
    
    if [ -z "$device_code" ] || [ -z "$user_code" ] || [ -z "$verification_uri" ]; then
        debug_log "Invalid device flow response"
        return 1
    fi
    
    # Save state to file
    echo "$flow_response" > "$state_file"
    chmod 600 "$state_file"
    
    # Start background polling process (properly detached)
    debug_log "Starting background polling process"
    
    # Export necessary variables and functions for the background process
    export -f poll_for_token_background
    export BROKER_URL
    export HOME
    
    # Start detached background process that will survive parent exit
    nohup bash -c "poll_for_token_background '$device_code' '$state_file' '${interval:-5}' '${expires_in:-900}'" </dev/null >/dev/null 2>&1 &
    
    # Disown the process so it's not killed when this script exits
    disown -h %1
    
    # Show user instructions
    echo "" >&2
    echo "=================================================================" >&2
    echo "  GitHub App Authentication Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  Please authorize the '$APP_NAME' GitHub App:" >&2
    echo "" >&2
    echo "  For humans:" >&2
    echo "  1. Visit: $verification_uri" >&2
    echo "  2. Enter code: $user_code" >&2
    echo "" >&2
    echo "  For AI agents - run these commands:" >&2
    echo "  echo '$user_code' | pbcopy" >&2
    echo "  open '$verification_uri'" >&2
    echo "" >&2
    echo "  Authentication will complete in the background." >&2
    echo "  Try your command again after authorizing." >&2
    echo "" >&2
    
    return 1
}

# Function to check as-a-bot authentication status
check_as_a_bot_status() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local cache_file="$cache_dir/token"

    echo "" >&2
    echo "=================================================================" >&2
    echo "  as-a-bot GitHub App Status" >&2
    echo "=================================================================" >&2
    echo "" >&2

    # Check if we have a cached token
    if [ ! -f "$cache_file" ]; then
        echo "  Status: Not authenticated" >&2
        echo "" >&2
        echo "  The as-a-bot GitHub App is not currently authenticated." >&2
        echo "  Authentication will be prompted when you perform operations" >&2
        echo "  from an AI tool that require proper attribution." >&2
        echo "" >&2
        return
    fi

    local cached_token
    cached_token=$(cat "$cache_file")

    # Try to verify the token
    if ! GH_TOKEN="$cached_token" "$GH_BIN" api user >/dev/null 2>&1; then
        echo "  Status: Invalid token (cached token expired)" >&2
        echo "" >&2
        echo "  The cached token has expired." >&2
        echo "  You will be prompted to re-authenticate when needed." >&2
        echo "" >&2
        return
    fi

    # Check token type
    if [[ "$cached_token" == ghu_* ]]; then
        echo "  Status: Authenticated ?" >&2
        echo "  Token type: User-to-server (ghu_)" >&2
        echo "" >&2

        # Get user info
        local user_login
        user_login=$(GH_TOKEN="$cached_token" "$GH_BIN" api user --jq '.login' 2>/dev/null)

        if [ -n "$user_login" ]; then
            echo "  Acting on behalf of: @$user_login" >&2
        fi

        # Check rate limit to verify token type
        local rate_limit
        rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)

        if [ -n "$rate_limit" ]; then
            echo "  Rate limit: $rate_limit/hour" >&2
            if [ "$rate_limit" = "15000" ]; then
                echo "  Attribution: Actions will show as '@$user_login (via as-a-bot[bot])'" >&2
            fi
        fi

        echo "" >&2
        echo "  To verify app installation in a repository, run:" >&2
        echo "    cd /path/to/repo && gh api repos/{owner}/{repo}/installation" >&2
        echo "" >&2
    else
        echo "  Status: Authenticated (warning)" >&2
        echo "  Token type: Unknown (doesn't have ghu_ prefix)" >&2
        echo "" >&2
        echo "  The token may not provide proper app attribution." >&2
        echo "  Consider re-authenticating by removing the cached token:" >&2
        echo "    rm -f $cache_file" >&2
        echo "" >&2
    fi
}

# Main script
GH_BIN=$(find_real_gh)
debug_log "Found gh at: $GH_BIN"

# Special handling for auth status - show both regular gh auth status and as-a-bot status
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    debug_log "Running auth status with as-a-bot checks"

    # First run the regular gh auth status
    "$GH_BIN" "$@"
    gh_exit_code=$?

    # Then show as-a-bot authentication status
    check_as_a_bot_status

    exit $gh_exit_code
fi

# Detect if an AI tool is running
AI_TOOL=$(detect_ai_tool)

if [ "$AI_TOOL" = "none" ]; then
    # No AI detected, pass through to regular gh
    debug_log "No AI detected, passing through to gh"
    exec "$GH_BIN" "$@"
fi

# AI detected - show info if in debug mode
if [ "$DEBUG" = "true" ]; then
    echo "[INFO] AI detected: $AI_TOOL - checking for bot token exchange..." >&2
fi

# Check if this is a safe operation that doesn't need token exchange
if is_safe_operation "$@"; then
    debug_log "Safe operation, skipping token exchange"
    exec "$GH_BIN" "$@"
fi

# Parse --repo flag if present
REPO_SPEC=""
if REPO_SPEC=$(parse_repo_flag "$@"); then
    debug_log "Found --repo flag: $REPO_SPEC"
fi

# Try to get repository info (either from --repo flag or current directory)
if ! read -r owner repo < <(get_repo_info "$REPO_SPEC"); then
    # For unsafe operations, we MUST have repository info to proceed with AI attribution
    echo "" >&2
    echo "=================================================================" >&2
    echo "  Repository Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  This operation requires repository context for proper AI attribution." >&2
    echo "" >&2
    echo "  Please either:" >&2
    echo "  1. Run this command from within a GitHub repository directory, or" >&2
    echo "  2. Use the --repo flag to specify the repository: --repo owner/repo" >&2
    echo "" >&2
    echo "  Refusing to proceed with user token to prevent misattribution." >&2
    echo "" >&2
    exit 1
fi

# Check if this repo should be ignored
debug_log "Checking if $owner/$repo should be ignored"
if should_ignore_repo "$owner" "$repo"; then
    debug_log "Repository is in ignore list, proceeding without bot attribution"
    exec "$GH_BIN" "$@"
fi
debug_log "Repository not in ignore list, will use device flow for authentication"

# Get or create user-to-server token via device flow
BOT_TOKEN=$(get_cached_token)
if [ -z "$BOT_TOKEN" ]; then
    echo "[ERROR] Authentication required. Please authorize and try again." >&2
    exit 1
fi

if [ "$DEBUG" = "true" ]; then
    # Verify token type
    if [[ "$BOT_TOKEN" == ghu_* ]]; then
        echo "[INFO] Using user-to-server token (ghu_) - actions will be attributed as 'you (via as-a-bot[bot])'" >&2
    else
        echo "[WARNING] Token doesn't have expected ghu_ prefix - attribution may not work correctly" >&2
    fi
fi

# Execute gh with the user-to-server token and handle GitHub App installation errors
execute_gh_with_error_handling() {
    local stderr_file
    local exit_code
    local timeout_seconds=60  # 1 minute timeout for agent mode

    # Create a temporary file for stderr
    stderr_file=$(mktemp)

    # Execute gh with timeout when AI tool is detected
    # Use a background process with timeout to detect hanging interactive prompts
    debug_log "Executing gh with ${timeout_seconds}s timeout for AI agent mode"

    # Start gh in background and capture its PID
    GH_TOKEN="$BOT_TOKEN" "$GH_BIN" "$@" 2>"$stderr_file" &
    local gh_pid=$!

    # Set up trap to kill background gh process on interrupts
    # This ensures the child process is terminated if the wrapper is cancelled
    trap 'kill -TERM "$gh_pid" 2>/dev/null; sleep 0.2; kill -KILL "$gh_pid" 2>/dev/null; rm -f "$stderr_file"; exit 130' INT TERM

    # Wait for the process with timeout
    local elapsed=0
    local sleep_interval=1
    while kill -0 "$gh_pid" 2>/dev/null; do
        if [ $elapsed -ge $timeout_seconds ]; then
            # Timeout reached - kill the gh process
            debug_log "Timeout reached after ${timeout_seconds}s, killing gh process"

            # Reset trap before killing process to avoid recursive trap execution
            trap - INT TERM

            kill -TERM "$gh_pid" 2>/dev/null
            sleep 0.5
            kill -KILL "$gh_pid" 2>/dev/null

            # Show timeout error with instructions
            echo "" >&2
            echo "=================================================================" >&2
            echo "  GitHub CLI Interactive Mode Timeout" >&2
            echo "=================================================================" >&2
            echo "" >&2
            echo "  AI tool detected: $AI_TOOL" >&2
            echo "" >&2
            echo "  The 'gh' command timed out after ${timeout_seconds} seconds." >&2
            echo "  This usually happens when gh opens an interactive dialog" >&2
            echo "  that requires user input." >&2
            echo "" >&2
            echo "  To fix this, run the command in non-interactive mode by" >&2
            echo "  piping the output to cat:" >&2
            echo "" >&2
            echo "    gh $* | cat" >&2
            echo "" >&2
            echo "  Or use command-line flags to avoid interactive prompts." >&2
            echo "  For example, 'gh pr create' can use --title and --body flags" >&2
            echo "  instead of opening an editor." >&2
            echo "" >&2

            rm -f "$stderr_file"
            exit 124  # Standard timeout exit code
        fi

        sleep $sleep_interval
        elapsed=$((elapsed + sleep_interval))
    done

    # Process completed within timeout, get exit code
    wait "$gh_pid"
    exit_code=$?

    # Reset trap now that process has completed
    trap - INT TERM

    debug_log "gh command completed with exit code $exit_code after ${elapsed}s"

    # If command failed, check for specific GitHub App errors
    if [ $exit_code -ne 0 ]; then
        local stderr_content
        stderr_content=$(cat "$stderr_file")

        debug_log "gh command failed with exit code $exit_code"
        debug_log "stderr: $stderr_content"

        # Check for GitHub App not installed error
        if echo "$stderr_content" | grep -qi "Resource not accessible by integration"; then
            echo "" >&2
            echo "=================================================================" >&2
            echo "  GitHub App Installation Required" >&2
            echo "=================================================================" >&2
            echo "" >&2
            echo "  The 'as-a-bot' GitHub App is not installed in this repository." >&2
            echo "" >&2
            echo "  To enable AI-aligned operations, please:" >&2
            echo "" >&2
            echo "  1. Visit: https://github.com/apps/as-a-bot" >&2
            echo "  2. Click 'Install' or 'Configure'" >&2
            echo "  3. Select the repository: $owner/$repo" >&2
            echo "  4. Grant the required permissions" >&2
            echo "" >&2
            echo "  After installation, try your command again." >&2
            echo "" >&2
            echo "  Original error:" >&2
            echo "  $stderr_content" >&2
            echo "" >&2
            rm -f "$stderr_file"
            exit 1
        fi

        # For other errors, just show the original error and exit
        cat "$stderr_file" >&2
        rm -f "$stderr_file"
        exit $exit_code
    fi

    # Clean up temp file on success
    rm -f "$stderr_file"
    exit 0
}

execute_gh_with_error_handling "$@"
