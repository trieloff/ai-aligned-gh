#!/bin/bash

# gh wrapper - Automatically detect AI tools and use bot token attribution via as-a-bot service
# This wrapper intercepts gh CLI calls and exchanges tokens when AI usage is detected
# AI detection powered by am-i-ai: https://github.com/trieloff/am-i-ai

# Configuration
BROKER_URL="${AS_A_BOT_URL:-https://as-bot-worker.minivelos.workers.dev}"
APP_NAME="as-a-bot"
DEBUG="${GH_AI_DEBUG:-false}"

# Function to print debug messages
debug_log() {
    if [ "$DEBUG" = "true" ]; then
        echo "[DEBUG] $*" >&2
    fi
}

# --- BEGIN BUNDLED am-i-ai ---
# Bundled from am-i-ai v1.0.0
# https://github.com/trieloff/am-i-ai
#
# This code is auto-generated. Do not edit manually.
# To update, run the propagate-updates workflow in am-i-ai.

ami_process_contains() {
    local pid=$1
    local pattern=$2
    if [[ "$OSTYPE" == "darwin"* ]]; then
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}

ami_check_env() {
    local detected=""
    [ -n "$CLAUDECODE" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ] && detected="$detected claude"
    [ -n "$GEMINI_CLI" ] && detected="$detected gemini"
    [ -n "$QWEN_CODE" ] && detected="$detected qwen"
    [ -n "$CURSOR_AI" ] && detected="$detected cursor"
    [ -n "$OPENCODE_AI" ] && detected="$detected opencode"
    [ -n "$CODEX_CLI" ] || [ -n "$CODEX_SANDBOX" ] && detected="$detected codex"
    [ "$OR_APP_NAME" = "Aider" ] && detected="$detected aider"

    # Zed detection - distinguish human from AI
    local tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
    if [ -n "$ZED_ENVIRONMENT" ]; then
        if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
            local parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
            case "$parent_comm" in
                bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash) ;;
                *) detected="$detected zed" ;;
            esac
        fi
    fi

    [ "$GITHUB_COPILOT_CLI_MODE" = "true" ] && detected="$detected copilot"
    [ -n "$DROID_CLI" ] && detected="$detected droid"
    [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ] && detected="$detected amp"
    [ -n "$KIMI_CLI" ] && detected="$detected kimi"
    [ "$OR_APP_NAME" = "OpenHands" ] || [ -n "$OR_SITE_URL" ] && detected="$detected openhands"
    [ -n "$GOOSE_TERMINAL" ] && detected="$detected goose"
    [ -n "$CLINE_TASK_ID" ] && detected="$detected cline"
    [ -n "$ROO_CODE_TASK_ID" ] && detected="$detected roo"
    [ -n "$WINDSURF_SESSION" ] || [ "$TERM_PROGRAM" = "windsurf" ] && detected="$detected windsurf"
    echo "$detected"
}

ami_check_ps_tree() {
    local detected="" current_pid=$$ max_depth=10 depth=0
    while [ $depth -lt $max_depth ]; do
        current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ] && break

        ami_process_contains "$current_pid" "claude" && detected="$detected claude"
        ami_process_contains "$current_pid" "gemini" && detected="$detected gemini"
        ami_process_contains "$current_pid" "codex" && detected="$detected codex"
        ami_process_contains "$current_pid" "aider" && detected="$detected aider"
        ami_process_contains "$current_pid" "qwen" && detected="$detected qwen"
        ami_process_contains "$current_pid" "opencode" && detected="$detected opencode"
        ami_process_contains "$current_pid" "cursor" && detected="$detected cursor"
        ami_process_contains "$current_pid" "kimi" && detected="$detected kimi"
        ami_process_contains "$current_pid" "crush" && detected="$detected crush"
        ami_process_contains "$current_pid" "goose" && detected="$detected goose"
        ami_process_contains "$current_pid" "cline" && detected="$detected cline"
        ami_process_contains "$current_pid" "roo" && detected="$detected roo"
        ami_process_contains "$current_pid" "windsurf" && detected="$detected windsurf"

        if ami_process_contains "$current_pid" "zed"; then
            local tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
            if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
                local parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
                case "$parent_comm" in
                    bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash) ;;
                    *) detected="$detected zed" ;;
                esac
            fi
        fi

        if [[ "$OSTYPE" == "darwin"* ]]; then
            { ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
              ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; } && detected="$detected droid"
        else
            { ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
              ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; } && detected="$detected droid"
        fi
        depth=$((depth + 1))
    done
    echo "$detected"
}

ami_detect() {
    local all_detected="$(ami_check_env) $(ami_check_ps_tree)"
    [[ "$all_detected" =~ "amp" ]] && echo "amp" && return
    [[ "$all_detected" =~ "codex" ]] && echo "codex" && return
    [[ "$all_detected" =~ "aider" ]] && echo "aider" && return
    [[ "$all_detected" =~ "claude" ]] && echo "claude" && return
    [[ "$all_detected" =~ "gemini" ]] && echo "gemini" && return
    [[ "$all_detected" =~ "qwen" ]] && echo "qwen" && return
    [[ "$all_detected" =~ "droid" ]] && echo "droid" && return
    [[ "$all_detected" =~ "opencode" ]] && echo "opencode" && return
    [[ "$all_detected" =~ "cursor" ]] && echo "cursor" && return
    [[ "$all_detected" =~ "copilot" ]] && echo "copilot" && return
    [[ "$all_detected" =~ "kimi" ]] && echo "kimi" && return
    [[ "$all_detected" =~ "openhands" ]] && echo "openhands" && return
    [[ "$all_detected" =~ "cline" ]] && echo "cline" && return
    [[ "$all_detected" =~ "roo" ]] && echo "roo" && return
    [[ "$all_detected" =~ "windsurf" ]] && echo "windsurf" && return
    [[ "$all_detected" =~ "crush" ]] && echo "crush" && return
    [[ "$all_detected" =~ "goose" ]] && echo "goose" && return
    [[ "$all_detected" =~ "zed" ]] && echo "zed" && return
    echo "none"
}

detect_ai_tool() { ami_detect; }
# --- END BUNDLED am-i-ai ---

# Function to find the real gh executable
find_real_gh() {
    # Common locations for gh
    local gh_paths=(
        "/usr/bin/gh"
        "/usr/local/bin/gh"
        "/opt/homebrew/bin/gh"
        "/opt/local/bin/gh"
        "/home/linuxbrew/.linuxbrew/bin/gh"
        "/snap/bin/gh"
    )

    for gh_path in "${gh_paths[@]}"; do
        if [ -x "$gh_path" ]; then
            echo "$gh_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        # Skip our own directory to avoid infinite recursion
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/gh" ]; then
            echo "$dir/gh"
            return
        fi
    done

    echo "gh not found" >&2
    exit 1
}

# Function to parse --repo flag from command arguments
parse_repo_flag() {
    local args=("$@")
    local i=0

    while [ $i -lt ${#args[@]} ]; do
        case "${args[i]}" in
            --repo)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
            --repo=*)
                echo "${args[i]#--repo=}"
                return 0
                ;;
            -R)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
        esac
        i=$((i + 1))
    done

    return 1
}

# Function to check if operation is safe (read-only)
is_safe_operation() {
    local cmd="$1"
    local subcommand="$2"

    case "$cmd" in
        help|--help|-h|version|--version)
            return 0
            ;;
        auth)
            case "$subcommand" in
                status|login|logout|refresh|setup-git|token)
                    return 0
                    ;;
            esac
            ;;
        repo)
            case "$subcommand" in
                view|list|clone|fork)
                    return 0
                    ;;
            esac
            ;;
        pr)
            case "$subcommand" in
                view|list|diff|checks)
                    return 0
                    ;;
            esac
            ;;
        issue)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        release)
            case "$subcommand" in
                view|list|download)
                    return 0
                    ;;
            esac
            ;;
        run)
            case "$subcommand" in
                view|list|watch)
                    return 0
                    ;;
            esac
            ;;
        workflow)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        api)
            # API calls with GET method only
            if [[ "$*" =~ --method[[:space:]]+GET|^GET[[:space:]] ]] || [[ ! "$*" =~ --method ]]; then
                # Default API calls are GET, but be conservative
                case "$subcommand" in
                    user|users/*|rate_limit|repos/*/|orgs/*)
                        return 0
                        ;;
                esac
            fi
            ;;
    esac

    return 1
}

# Function to get current repository info
get_repo_info() {
    local repo_spec="$1"  # Optional: explicit repo specification
    local name_with_owner

    if [ -n "$repo_spec" ]; then
        # Use explicit repo specification
        debug_log "Using explicit repo specification: $repo_spec"
        name_with_owner="$repo_spec"
    else
        # Try to get repo info from current directory using gh
        debug_log "Attempting to get repo info from current directory"
        name_with_owner=$("$GH_BIN" repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null)

        if [ -z "$name_with_owner" ] || [ "$name_with_owner" = "null" ]; then
            debug_log "No repository found in current directory"
            return 1
        fi
    fi

    debug_log "Found repository: $name_with_owner"

    # Split owner/repo
    if [[ "$name_with_owner" =~ ^([^/]+)/(.+)$ ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        echo "$owner" "$repo"
        debug_log "Parsed owner: $owner, repo: $repo"
        return 0
    fi

    debug_log "Could not parse owner/repo from: $name_with_owner"
    return 1
}

# Function to check if a repo should be ignored
should_ignore_repo() {
    local owner=$1
    local repo=$2
    local config_file="$HOME/.config/ai-aligned-gh/ignorerepos"

    debug_log "Looking for ignore file at: $config_file"

    # If config file doesn't exist, don't ignore
    if [ ! -f "$config_file" ]; then
        debug_log "Ignore file not found"
        return 1
    fi

    debug_log "Found ignore file, checking patterns"

    # Check each pattern in the ignore file
    while IFS= read -r pattern || [ -n "$pattern" ]; do
        # Skip empty lines and comments
        if [[ -z "$pattern" ]] || [[ "$pattern" =~ ^[[:space:]]*# ]]; then
            continue
        fi

        # Trim whitespace
        pattern=$(echo "$pattern" | xargs)

        debug_log "Checking pattern: '$pattern' against '$owner/$repo'"

        # Check if pattern matches owner/repo exactly
        if [[ "$owner/$repo" == "$pattern" ]]; then
            debug_log "Repository $owner/$repo matches ignore pattern: $pattern"
            return 0
        fi

        # Check if pattern is owner/* (matches all repos in org)
        if [[ "$pattern" == *"/*" ]] && [[ "$owner" == "${pattern%/*}" ]]; then
            debug_log "Repository $owner/$repo matches org pattern: $pattern"
            return 0
        fi
    done < "$config_file"

    return 1
}

# Function to start device flow authentication
start_device_flow() {
    local scopes="${1:-repo}"

    debug_log "Starting device flow authentication with scopes: $scopes"

    local response
    response=$(curl -sS -X POST "${BROKER_URL}/user-token/start" \
        -H "Content-Type: application/json" \
        -d "{\"scopes\":\"${scopes}\"}" 2>/dev/null)

    if [ -z "$response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi

    echo "$response"
    return 0
}

# Function to poll for device flow token in background
poll_for_token_background() {
    local device_code=$1
    local state_file=$2
    local interval=${3:-5}
    local max_time=${4:-300}  # Max 5 minutes by default

    local start_time
    start_time=$(date +%s)

    while true; do
        local current_time
        current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        if [ "$elapsed" -gt "$max_time" ]; then
            echo "expired" > "${state_file}.status"
            break
        fi

        local response
        response=$(curl -sS -X POST "${BROKER_URL}/user-token/poll" \
            -H "Content-Type: application/json" \
            -d "{\"device_code\":\"${device_code}\"}" 2>/dev/null)

        local access_token
        access_token=$(echo "$response" | jq -r '.access_token' 2>/dev/null)

        if [ -n "$access_token" ] && [ "$access_token" != "null" ]; then
            # Save the token to cache
            echo "$access_token" > "$HOME/.cache/ai-aligned-gh/token"
            chmod 600 "$HOME/.cache/ai-aligned-gh/token"
            echo "completed" > "${state_file}.status"
            rm -f "$state_file"
            break
        fi

        local error
        error=$(echo "$response" | jq -r '.error' 2>/dev/null)

        if [ "$error" = "authorization_pending" ] || [ "$error" = "server_error" ]; then
            sleep "$interval"
        elif [ "$error" = "slow_down" ]; then
            interval=$((interval + 5))
            sleep "$interval"
        elif [ -n "$error" ] && [ "$error" != "null" ]; then
            echo "failed: $error" > "${state_file}.status"
            break
        fi
    done
}

# Function to get or create cached token
get_cached_token() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local state_dir="$HOME/.config/ai-aligned-gh/auth"
    local cache_file="$cache_dir/token"
    local state_file="$state_dir/device_flow.json"

    # Create directories if they don't exist
    mkdir -p "$cache_dir" "$state_dir"

    # Check if cached token exists and is still valid
    if [ -f "$cache_file" ]; then
        local cached_token
        cached_token=$(cat "$cache_file")

        # Verify token is still valid and check its type
        local rate_limit

        if GH_TOKEN="$cached_token" "$GH_BIN" api user >/dev/null 2>&1; then
            # Check if this is a user-to-server token (ghu_ prefix)
            if [[ "$cached_token" == ghu_* ]]; then
                debug_log "Using valid user-to-server token (ghu_ prefix)"

                # Optionally check rate limit to confirm it's a proper GitHub App token
                if [ "$DEBUG" = "true" ]; then
                    rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)
                    debug_log "Token rate limit: $rate_limit (15000=GitHub App user token, 5000=OAuth token)"
                fi
            else
                debug_log "WARNING: Token doesn't have ghu_ prefix, may not have app attribution"
            fi

            echo "$cached_token"
            return 0
        else
            debug_log "Cached token is invalid, removing it"
            rm -f "$cache_file"
        fi
    fi

    # Check if there's an in-progress device flow
    if [ -f "$state_file" ]; then
        local state_age=$(($(date +%s) - $(stat -f %m "$state_file" 2>/dev/null || stat -c %Y "$state_file" 2>/dev/null)))

        # If state file is less than 15 minutes old
        if [ $state_age -lt 900 ]; then
            debug_log "Found recent device flow state (${state_age}s old)"

            # Check if there's a status file indicating completion
            if [ -f "${state_file}.status" ]; then
                local status
                status=$(cat "${state_file}.status")

                if [ "$status" = "completed" ]; then
                    # Token should have been saved, try again
                    rm -f "${state_file}.status"
                    if [ -f "$cache_file" ]; then
                        cached_token=$(cat "$cache_file")
                        echo "$cached_token"
                        return 0
                    fi
                elif [[ "$status" == "failed:"* ]]; then
                    echo "[ERROR] Previous authentication failed: ${status#failed: }" >&2
                    rm -f "$state_file" "${state_file}.status"
                elif [ "$status" = "expired" ]; then
                    echo "[ERROR] Previous authentication expired" >&2
                    rm -f "$state_file" "${state_file}.status"
                fi
            else
                # Still in progress, show the existing code
                local user_code verification_uri
                user_code=$(jq -r '.user_code' "$state_file" 2>/dev/null)
                verification_uri=$(jq -r '.verification_uri' "$state_file" 2>/dev/null)

                if [ -n "$user_code" ] && [ -n "$verification_uri" ]; then
                    echo "" >&2
                    echo "=================================================================" >&2
                    echo "  GitHub App Authentication Already In Progress" >&2
                    echo "=================================================================" >&2
                    echo "" >&2
                    echo "  AI tool detected: $AI_TOOL" >&2
                    echo "" >&2
                    echo "  Please complete the authorization:" >&2
                    echo "" >&2
                    echo "  For humans:" >&2
                    echo "  1. Visit: $verification_uri" >&2
                    echo "  2. Enter code: $user_code" >&2
                    echo "" >&2
                    echo "  For AI agents - run these commands:" >&2
                    echo "  echo '$user_code' | pbcopy" >&2
                    echo "  open '$verification_uri'" >&2
                    echo "" >&2
                    echo "  Authentication will complete in the background." >&2
                    echo "  Try your command again in a few seconds." >&2
                    echo "" >&2
                    return 1
                fi
            fi
        else
            debug_log "Device flow state is too old (${state_age}s), removing"
            rm -f "$state_file" "${state_file}.status"
        fi
    fi

    # No valid cached token or in-progress flow, start new auth flow
    debug_log "Starting new authentication flow"

    # Use device flow for CLI (doesn't require browser redirect)
    debug_log "Starting device flow for CLI authentication"
    flow_response=$(start_device_flow "")

    if [ -z "$flow_response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi

    local device_code user_code verification_uri expires_in interval
    device_code=$(echo "$flow_response" | jq -r '.device_code' 2>/dev/null)
    user_code=$(echo "$flow_response" | jq -r '.user_code' 2>/dev/null)
    verification_uri=$(echo "$flow_response" | jq -r '.verification_uri' 2>/dev/null)
    expires_in=$(echo "$flow_response" | jq -r '.expires_in' 2>/dev/null)
    interval=$(echo "$flow_response" | jq -r '.interval' 2>/dev/null)

    if [ -z "$device_code" ] || [ -z "$user_code" ] || [ -z "$verification_uri" ]; then
        debug_log "Invalid device flow response"
        return 1
    fi

    # Save state to file
    echo "$flow_response" > "$state_file"
    chmod 600 "$state_file"

    # Start background polling process (properly detached)
    debug_log "Starting background polling process"

    # Export necessary variables and functions for the background process
    export -f poll_for_token_background
    export BROKER_URL
    export HOME

    # Start detached background process that will survive parent exit
    nohup bash -c "poll_for_token_background '$device_code' '$state_file' '${interval:-5}' '${expires_in:-900}'" </dev/null >/dev/null 2>&1 &

    # Disown the process so it's not killed when this script exits
    disown -h %1

    # Show user instructions
    echo "" >&2
    echo "=================================================================" >&2
    echo "  GitHub App Authentication Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  Please authorize the '$APP_NAME' GitHub App:" >&2
    echo "" >&2
    echo "  For humans:" >&2
    echo "  1. Visit: $verification_uri" >&2
    echo "  2. Enter code: $user_code" >&2
    echo "" >&2
    echo "  For AI agents - run these commands:" >&2
    echo "  echo '$user_code' | pbcopy" >&2
    echo "  open '$verification_uri'" >&2
    echo "" >&2
    echo "  Authentication will complete in the background." >&2
    echo "  Try your command again after authorizing." >&2
    echo "" >&2

    return 1
}

# Function to check as-a-bot authentication status
check_as_a_bot_status() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local cache_file="$cache_dir/token"

    echo "" >&2
    echo "=================================================================" >&2
    echo "  as-a-bot GitHub App Status" >&2
    echo "=================================================================" >&2
    echo "" >&2

    # Check if we have a cached token
    if [ ! -f "$cache_file" ]; then
        echo "  Status: Not authenticated" >&2
        echo "" >&2
        echo "  The as-a-bot GitHub App is not currently authenticated." >&2
        echo "  Authentication will be prompted when you perform operations" >&2
        echo "  from an AI tool that require proper attribution." >&2
        echo "" >&2
        return
    fi

    local cached_token
    cached_token=$(cat "$cache_file")

    # Try to verify the token
    if ! GH_TOKEN="$cached_token" "$GH_BIN" api user >/dev/null 2>&1; then
        echo "  Status: Invalid token (cached token expired)" >&2
        echo "" >&2
        echo "  The cached token has expired." >&2
        echo "  You will be prompted to re-authenticate when needed." >&2
        echo "" >&2
        return
    fi

    # Check token type
    if [[ "$cached_token" == ghu_* ]]; then
        echo "  Status: Authenticated ?" >&2
        echo "  Token type: User-to-server (ghu_)" >&2
        echo "" >&2

        # Get user info
        local user_login
        user_login=$(GH_TOKEN="$cached_token" "$GH_BIN" api user --jq '.login' 2>/dev/null)

        if [ -n "$user_login" ]; then
            echo "  Acting on behalf of: @$user_login" >&2
        fi

        # Check rate limit to verify token type
        local rate_limit
        rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)

        if [ -n "$rate_limit" ]; then
            echo "  Rate limit: $rate_limit/hour" >&2
            if [ "$rate_limit" = "15000" ]; then
                echo "  Attribution: Actions will show as '@$user_login (via as-a-bot[bot])'" >&2
            fi
        fi

        echo "" >&2
        echo "  To verify app installation in a repository, run:" >&2
        echo "    cd /path/to/repo && gh api repos/{owner}/{repo}/installation" >&2
        echo "" >&2
    else
        echo "  Status: Authenticated (warning)" >&2
        echo "  Token type: Unknown (doesn't have ghu_ prefix)" >&2
        echo "" >&2
        echo "  The token may not provide proper app attribution." >&2
        echo "  Consider re-authenticating by removing the cached token:" >&2
        echo "    rm -f $cache_file" >&2
        echo "" >&2
    fi
}

# Main script
GH_BIN=$(find_real_gh)
debug_log "Found gh at: $GH_BIN"

# Special handling for auth status - show both regular gh auth status and as-a-bot status
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    debug_log "Running auth status with as-a-bot checks"

    # First run the regular gh auth status
    "$GH_BIN" "$@"
    gh_exit_code=$?

    # Then show as-a-bot authentication status
    check_as_a_bot_status

    exit $gh_exit_code
fi

# Detect if an AI tool is running
AI_TOOL=$(detect_ai_tool)

if [ "$AI_TOOL" = "none" ]; then
    # No AI detected, pass through to regular gh
    debug_log "No AI detected, passing through to gh"
    exec "$GH_BIN" "$@"
fi

# AI detected - show info if in debug mode
if [ "$DEBUG" = "true" ]; then
    echo "[INFO] AI detected: $AI_TOOL - checking for bot token exchange..." >&2
fi

# Check if this is a safe operation that doesn't need token exchange
if is_safe_operation "$@"; then
    debug_log "Safe operation, skipping token exchange"
    exec "$GH_BIN" "$@"
fi

# Parse --repo flag if present
REPO_SPEC=""
if REPO_SPEC=$(parse_repo_flag "$@"); then
    debug_log "Found --repo flag: $REPO_SPEC"
fi

# Try to get repository info (either from --repo flag or current directory)
if ! read -r owner repo < <(get_repo_info "$REPO_SPEC"); then
    # For unsafe operations, we MUST have repository info to proceed with AI attribution
    echo "" >&2
    echo "=================================================================" >&2
    echo "  Repository Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  This operation requires repository context for proper AI attribution." >&2
    echo "" >&2
    echo "  Please either:" >&2
    echo "  1. Run this command from within a GitHub repository directory, or" >&2
    echo "  2. Use the --repo flag to specify the repository: --repo owner/repo" >&2
    echo "" >&2
    echo "  Refusing to proceed with user token to prevent misattribution." >&2
    echo "" >&2
    exit 1
fi

# Check if this repo should be ignored
debug_log "Checking if $owner/$repo should be ignored"
if should_ignore_repo "$owner" "$repo"; then
    debug_log "Repository is in ignore list, proceeding without bot attribution"
    exec "$GH_BIN" "$@"
fi
debug_log "Repository not in ignore list, will use device flow for authentication"

# Get or create user-to-server token via device flow
BOT_TOKEN=$(get_cached_token)
if [ -z "$BOT_TOKEN" ]; then
    echo "[ERROR] Authentication required. Please authorize and try again." >&2
    exit 1
fi

if [ "$DEBUG" = "true" ]; then
    # Verify token type
    if [[ "$BOT_TOKEN" == ghu_* ]]; then
        echo "[INFO] Using user-to-server token (ghu_) - actions will be attributed as 'you (via as-a-bot[bot])'" >&2
    else
        echo "[WARNING] Token doesn't have expected ghu_ prefix - attribution may not work correctly" >&2
    fi
fi

# Execute gh with the user-to-server token and handle GitHub App installation errors
execute_gh_with_error_handling() {
    local stderr_file
    local exit_code

    # Create a temporary file for stderr
    stderr_file=$(mktemp)

    # Execute gh with stderr redirected to temp file
    GH_TOKEN="$BOT_TOKEN" "$GH_BIN" "$@" 2>"$stderr_file"
    exit_code=$?

    # If command failed, check for specific GitHub App errors
    if [ $exit_code -ne 0 ]; then
        local stderr_content
        stderr_content=$(cat "$stderr_file")

        debug_log "gh command failed with exit code $exit_code"
        debug_log "stderr: $stderr_content"

        # Check for GitHub App not installed error
        if echo "$stderr_content" | grep -qi "Resource not accessible by integration"; then
            echo "" >&2
            echo "=================================================================" >&2
            echo "  GitHub App Installation Required" >&2
            echo "=================================================================" >&2
            echo "" >&2
            echo "  The 'as-a-bot' GitHub App is not installed in this repository." >&2
            echo "" >&2
            echo "  To enable AI-aligned operations, please:" >&2
            echo "" >&2
            echo "  1. Visit: https://github.com/apps/as-a-bot" >&2
            echo "  2. Click 'Install' or 'Configure'" >&2
            echo "  3. Select the repository: $owner/$repo" >&2
            echo "  4. Grant the required permissions" >&2
            echo "" >&2
            echo "  After installation, try your command again." >&2
            echo "" >&2
            echo "  Original error:" >&2
            echo "  $stderr_content" >&2
            echo "" >&2
            rm -f "$stderr_file"
            exit 1
        fi

        # For other errors, just show the original error and exit
        cat "$stderr_file" >&2
        rm -f "$stderr_file"
        exit $exit_code
    fi

    # Clean up temp file on success
    rm -f "$stderr_file"
    exit 0
}

execute_gh_with_error_handling "$@"
