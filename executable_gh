#!/bin/bash

# gh wrapper - Automatically detect AI tools and use bot token attribution via as-a-bot service
# This wrapper intercepts gh CLI calls and exchanges tokens when AI usage is detected

# Configuration
BROKER_URL="${AS_A_BOT_URL:-https://as-bot-worker.minivelos.workers.dev}"
APP_NAME="as-a-bot"
DEBUG="${GH_AI_DEBUG:-false}"

# Function to print debug messages
debug_log() {
    if [ "$DEBUG" = "true" ]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Function to check if a process name contains a pattern (case-insensitive)
process_contains() {
    local pid=$1
    local pattern=$2

    # Get process command and name
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        # Linux
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}

# Function to detect which AI tool is running
detect_ai_tool() {
    local current_pid=$$
    local max_depth=10
    local depth=0

    debug_log "Starting AI detection from PID $current_pid"

    # Check environment variables first
    if [ -n "$GEMINI_CLI" ]; then
        debug_log "Detected Gemini via environment variable"
        echo "gemini"
        return
    fi
    if [ -n "$QWEN_CODE" ]; then
        debug_log "Detected Qwen via environment variable"
        echo "qwen"
        return
    fi
    if [ -n "$CLAUDE_CODE" ] || [ -n "$ANTHROPIC_SHELL" ]; then
        debug_log "Detected Claude via environment variable"
        echo "claude"
        return
    fi
    if [ -n "$CURSOR_AI" ]; then
        debug_log "Detected Cursor via environment variable"
        echo "cursor"
        return
    fi
    if [ -n "$ZED_AI" ]; then
        debug_log "Detected Zed via environment variable"
        echo "zed"
        return
    fi
    if [ -n "$OPENCODE_AI" ]; then
        debug_log "Detected OpenCode via environment variable"
        echo "opencode"
        return
    fi

    # Walk up the process tree
    while [ $depth -lt $max_depth ]; do
        # Get parent PID
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        else
            # Linux
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        fi

        # Check if we've reached the top
        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            debug_log "Reached top of process tree without finding AI"
            break
        fi

        debug_log "Checking PID $current_pid at depth $depth"

        # Check for AI tool patterns in process names
        if process_contains "$current_pid" "claude"; then
            debug_log "Detected Claude in process tree"
            echo "claude"
            return
        elif process_contains "$current_pid" "gemini"; then
            debug_log "Detected Gemini in process tree"
            echo "gemini"
            return
        elif process_contains "$current_pid" "qwen"; then
            debug_log "Detected Qwen in process tree"
            echo "qwen"
            return
        elif process_contains "$current_pid" "zed"; then
            debug_log "Detected Zed in process tree"
            echo "zed"
            return
        elif process_contains "$current_pid" "opencode"; then
            debug_log "Detected OpenCode in process tree"
            echo "opencode"
            return
        elif process_contains "$current_pid" "cursor"; then
            debug_log "Detected Cursor in process tree"
            echo "cursor"
            return
        fi

        depth=$((depth + 1))
    done

    debug_log "No AI tool detected"
    echo "none"
}

# Function to find the real gh executable
find_real_gh() {
    # Common locations for gh
    local gh_paths=(
        "/usr/bin/gh"
        "/usr/local/bin/gh"
        "/opt/homebrew/bin/gh"
        "/opt/local/bin/gh"
        "/home/linuxbrew/.linuxbrew/bin/gh"
        "/snap/bin/gh"
    )

    for gh_path in "${gh_paths[@]}"; do
        if [ -x "$gh_path" ]; then
            echo "$gh_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        # Skip our own directory to avoid infinite recursion
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/gh" ]; then
            echo "$dir/gh"
            return
        fi
    done

    echo "gh not found" >&2
    exit 1
}

# Function to get current repository info
get_repo_info() {
    # Try to get repo info from current directory
    local origin_url
    origin_url=$(git config --get remote.origin.url 2>/dev/null || echo "")
    
    if [ -z "$origin_url" ]; then
        debug_log "No git remote origin found"
        return 1
    fi

    debug_log "Found origin URL: $origin_url"

    # Parse GitHub owner/repo from various URL formats
    if [[ "$origin_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
        repo="${repo%.git}"  # Remove .git suffix if present
        echo "$owner" "$repo"
        debug_log "Parsed owner: $owner, repo: $repo"
        return 0
    fi

    debug_log "Could not parse GitHub owner/repo from URL"
    return 1
}

# Function to check if a repo should be ignored
should_ignore_repo() {
    local owner=$1
    local repo=$2
    local config_file="$HOME/.config/ai-aligned-gh/ignorerepos"
    
    debug_log "Looking for ignore file at: $config_file"
    
    # If config file doesn't exist, don't ignore
    if [ ! -f "$config_file" ]; then
        debug_log "Ignore file not found"
        return 1
    fi
    
    debug_log "Found ignore file, checking patterns"
    
    # Check each pattern in the ignore file
    while IFS= read -r pattern || [ -n "$pattern" ]; do
        # Skip empty lines and comments
        if [[ -z "$pattern" ]] || [[ "$pattern" =~ ^[[:space:]]*# ]]; then
            continue
        fi
        
        # Trim whitespace
        pattern=$(echo "$pattern" | xargs)
        
        debug_log "Checking pattern: '$pattern' against '$owner/$repo'"
        
        # Check if pattern matches owner/repo exactly
        if [[ "$owner/$repo" == "$pattern" ]]; then
            debug_log "Repository $owner/$repo matches ignore pattern: $pattern"
            return 0
        fi
        
        # Check if pattern is owner/* (matches all repos in org)
        if [[ "$pattern" == *"/*" ]] && [[ "$owner" == "${pattern%/*}" ]]; then
            debug_log "Repository $owner/$repo matches org pattern: $pattern"
            return 0
        fi
    done < "$config_file"
    
    return 1
}

# Function to start device flow authentication
start_device_flow() {
    local scopes="${1:-repo}"
    
    debug_log "Starting device flow authentication with scopes: $scopes"
    
    local response
    response=$(curl -sS -X POST "${BROKER_URL}/user-token/start" \
        -H "Content-Type: application/json" \
        -d "{\"scopes\":\"${scopes}\"}" 2>/dev/null)
    
    if [ -z "$response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    echo "$response"
    return 0
}

# Function to start web flow authentication
start_web_flow() {
    debug_log "Starting web flow authentication"
    
    local response
    response=$(curl -sS -X POST "${BROKER_URL}/auth/start" \
        -H "Content-Type: application/json" \
        -d "{}" 2>/dev/null)
    
    if [ -z "$response" ]; then
        debug_log "Failed to start web flow"
        return 1
    fi
    
    echo "$response"
    return 0
}

# Function to poll for device flow token in background
poll_for_token_background() {
    local device_code=$1
    local state_file=$2
    local interval=${3:-5}
    local max_time=${4:-300}  # Max 5 minutes by default
    
    local start_time=$(date +%s)
    
    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [ $elapsed -gt $max_time ]; then
            echo "expired" > "${state_file}.status"
            break
        fi
        
        local response
        response=$(curl -sS -X POST "${BROKER_URL}/user-token/poll" \
            -H "Content-Type: application/json" \
            -d "{\"device_code\":\"${device_code}\"}" 2>/dev/null)
        
        local access_token
        access_token=$(echo "$response" | jq -r '.access_token' 2>/dev/null)
        
        if [ -n "$access_token" ] && [ "$access_token" != "null" ]; then
            # Save the token to cache
            echo "$access_token" > "$HOME/.cache/ai-aligned-gh/token"
            chmod 600 "$HOME/.cache/ai-aligned-gh/token"
            echo "completed" > "${state_file}.status"
            rm -f "$state_file"
            break
        fi
        
        local error
        error=$(echo "$response" | jq -r '.error' 2>/dev/null)
        
        if [ "$error" = "authorization_pending" ] || [ "$error" = "server_error" ]; then
            sleep "$interval"
        elif [ "$error" = "slow_down" ]; then
            interval=$((interval + 5))
            sleep "$interval"
        elif [ -n "$error" ] && [ "$error" != "null" ]; then
            echo "failed: $error" > "${state_file}.status"
            break
        fi
    done
}

# Function to get or create cached token
get_cached_token() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local state_dir="$HOME/.config/ai-aligned-gh/auth"
    local cache_file="$cache_dir/token"
    local state_file="$state_dir/device_flow.json"
    
    # Create directories if they don't exist
    mkdir -p "$cache_dir" "$state_dir"
    
    # Check if cached token exists and is still valid
    if [ -f "$cache_file" ]; then
        local cached_token
        cached_token=$(cat "$cache_file")
        
        # Verify token is still valid and check its type
        local test_response rate_limit
        test_response=$(GH_TOKEN="$cached_token" "$GH_BIN" api user 2>/dev/null)
        
        if [ $? -eq 0 ]; then
            # Check if this is a user-to-server token (ghu_ prefix)
            if [[ "$cached_token" == ghu_* ]]; then
                debug_log "Using valid user-to-server token (ghu_ prefix)"
                
                # Optionally check rate limit to confirm it's a proper GitHub App token
                if [ "$DEBUG" = "true" ]; then
                    rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)
                    debug_log "Token rate limit: $rate_limit (15000=GitHub App user token, 5000=OAuth token)"
                fi
            else
                debug_log "WARNING: Token doesn't have ghu_ prefix, may not have app attribution"
            fi
            
            echo "$cached_token"
            return 0
        else
            debug_log "Cached token is invalid, removing it"
            rm -f "$cache_file"
        fi
    fi
    
    # Check if there's an in-progress device flow
    if [ -f "$state_file" ]; then
        local state_age=$(($(date +%s) - $(stat -f %m "$state_file" 2>/dev/null || stat -c %Y "$state_file" 2>/dev/null)))
        
        # If state file is less than 15 minutes old
        if [ $state_age -lt 900 ]; then
            debug_log "Found recent device flow state (${state_age}s old)"
            
            # Check if there's a status file indicating completion
            if [ -f "${state_file}.status" ]; then
                local status
                status=$(cat "${state_file}.status")
                
                if [ "$status" = "completed" ]; then
                    # Token should have been saved, try again
                    rm -f "${state_file}.status"
                    if [ -f "$cache_file" ]; then
                        cached_token=$(cat "$cache_file")
                        echo "$cached_token"
                        return 0
                    fi
                elif [[ "$status" == "failed:"* ]]; then
                    echo "[ERROR] Previous authentication failed: ${status#failed: }" >&2
                    rm -f "$state_file" "${state_file}.status"
                elif [ "$status" = "expired" ]; then
                    echo "[ERROR] Previous authentication expired" >&2
                    rm -f "$state_file" "${state_file}.status"
                fi
            else
                # Still in progress, show the existing code
                local user_code verification_uri
                user_code=$(jq -r '.user_code' "$state_file" 2>/dev/null)
                verification_uri=$(jq -r '.verification_uri' "$state_file" 2>/dev/null)
                
                if [ -n "$user_code" ] && [ -n "$verification_uri" ]; then
                    echo "" >&2
                    echo "=================================================================" >&2
                    echo "  GitHub App Authentication Already In Progress" >&2
                    echo "=================================================================" >&2
                    echo "" >&2
                    echo "  AI tool detected: $AI_TOOL" >&2
                    echo "" >&2
                    echo "  Please complete the authorization:" >&2
                    echo "" >&2
                    echo "  1. Visit: $verification_uri" >&2
                    echo "  2. Enter code: $user_code" >&2
                    echo "" >&2
                    echo "  Authentication will complete in the background." >&2
                    echo "  Try your command again in a few seconds." >&2
                    echo "" >&2
                    return 1
                fi
            fi
        else
            debug_log "Device flow state is too old (${state_age}s), removing"
            rm -f "$state_file" "${state_file}.status"
        fi
    fi
    
    # No valid cached token or in-progress flow, start new auth flow
    debug_log "Starting new authentication flow"
    
    # Try web flow first (should give user-to-server tokens)
    local flow_response
    flow_response=$(start_web_flow)
    
    if [ -n "$flow_response" ]; then
        # Web flow started successfully
        local auth_url state
        auth_url=$(echo "$flow_response" | jq -r '.auth_url' 2>/dev/null)
        state=$(echo "$flow_response" | jq -r '.state' 2>/dev/null)
        
        if [ -n "$auth_url" ] && [ -n "$state" ]; then
            # Show user instructions for web flow
            echo "" >&2
            echo "=================================================================" >&2
            echo "  GitHub App Authentication Required for AI-Aligned Operations" >&2
            echo "=================================================================" >&2
            echo "" >&2
            echo "  AI tool detected: $AI_TOOL" >&2
            echo "" >&2
            echo "  Please authorize the '$APP_NAME' GitHub App:" >&2
            echo "" >&2
            echo "  1. Open this URL in your browser:" >&2
            echo "     $auth_url" >&2
            echo "" >&2
            echo "  2. Authorize the application" >&2
            echo "" >&2
            echo "  Authentication will complete in the background." >&2
            echo "  Try your command again after authorizing." >&2
            echo "" >&2
            
            # Save state for polling
            echo "$state" > "$state_file"
            chmod 600 "$state_file"
            
            # Start background polling for web flow
            (
                nohup bash -c "
                    for i in {1..60}; do
                        response=\$(curl -sS -X POST '${BROKER_URL}/auth/poll' \
                            -H 'Content-Type: application/json' \
                            -d '{\"state\":\"$state\"}' 2>/dev/null)
                        
                        token=\$(echo \"\$response\" | jq -r '.access_token' 2>/dev/null)
                        
                        if [ -n \"\$token\" ] && [ \"\$token\" != \"null\" ]; then
                            echo \"\$token\" > '$cache_file'
                            chmod 600 '$cache_file'
                            echo 'completed' > '${state_file}.status'
                            rm -f '$state_file'
                            break
                        fi
                        
                        error=\$(echo \"\$response\" | jq -r '.error' 2>/dev/null)
                        if [ \"\$error\" = \"authorization_pending\" ]; then
                            sleep 5
                        else
                            break
                        fi
                    done
                " </dev/null >/dev/null 2>&1 &
            ) &
            disown -h %1
            
            return 1
        fi
    fi
    
    # Fall back to device flow if web flow fails
    debug_log "Web flow failed, falling back to device flow"
    flow_response=$(start_device_flow "")
    
    if [ -z "$flow_response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    local device_code user_code verification_uri expires_in interval
    device_code=$(echo "$flow_response" | jq -r '.device_code' 2>/dev/null)
    user_code=$(echo "$flow_response" | jq -r '.user_code' 2>/dev/null)
    verification_uri=$(echo "$flow_response" | jq -r '.verification_uri' 2>/dev/null)
    expires_in=$(echo "$flow_response" | jq -r '.expires_in' 2>/dev/null)
    interval=$(echo "$flow_response" | jq -r '.interval' 2>/dev/null)
    
    if [ -z "$device_code" ] || [ -z "$user_code" ] || [ -z "$verification_uri" ]; then
        debug_log "Invalid device flow response"
        return 1
    fi
    
    # Save state to file
    echo "$flow_response" > "$state_file"
    chmod 600 "$state_file"
    
    # Start background polling process (properly detached)
    debug_log "Starting background polling process"
    
    # Export necessary variables and functions for the background process
    export -f poll_for_token_background
    export BROKER_URL
    export HOME
    
    # Start detached background process that will survive parent exit
    nohup bash -c "poll_for_token_background '$device_code' '$state_file' '${interval:-5}' '${expires_in:-900}'" </dev/null >/dev/null 2>&1 &
    
    # Disown the process so it's not killed when this script exits
    disown -h %1
    
    # Show user instructions
    echo "" >&2
    echo "=================================================================" >&2
    echo "  GitHub App Authentication Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  Please authorize the '$APP_NAME' GitHub App:" >&2
    echo "" >&2
    echo "  1. Visit: $verification_uri" >&2
    echo "  2. Enter code: $user_code" >&2
    echo "" >&2
    echo "  Authentication will complete in the background." >&2
    echo "  Try your command again after authorizing." >&2
    echo "" >&2
    
    return 1
}

# Main script
GH_BIN=$(find_real_gh)
debug_log "Found gh at: $GH_BIN"

# Detect if an AI tool is running
AI_TOOL=$(detect_ai_tool)

if [ "$AI_TOOL" = "none" ]; then
    # No AI detected, pass through to regular gh
    debug_log "No AI detected, passing through to gh"
    exec "$GH_BIN" "$@"
fi

# AI detected - show info if in debug mode or if it's a write operation
if [ "$DEBUG" = "true" ]; then
    echo "[INFO] AI detected: $AI_TOOL - checking for bot token exchange..." >&2
fi

# Check if this is a read-only operation (we might not need token exchange for these)
NEEDS_TOKEN_EXCHANGE=true
case "$1" in
    help|--help|-h|version|--version)
        NEEDS_TOKEN_EXCHANGE=false
        ;;
    *)
        # For subcommands, check if they're read-only
        case "$1 $2" in
            "auth status"|"repo view"|"pr view"|"issue view"|"pr list"|"issue list")
                NEEDS_TOKEN_EXCHANGE=false
                ;;
        esac
        ;;
esac

if [ "$NEEDS_TOKEN_EXCHANGE" = "false" ]; then
    debug_log "Read-only operation, skipping token exchange"
    exec "$GH_BIN" "$@"
fi

# Try to get repository info
if ! read -r owner repo < <(get_repo_info); then
    debug_log "Could not determine repository, proceeding without bot attribution"
    exec "$GH_BIN" "$@"
fi

# Check if this repo should be ignored
debug_log "Checking if $owner/$repo should be ignored"
if should_ignore_repo "$owner" "$repo"; then
    debug_log "Repository is in ignore list, proceeding without bot attribution"
    exec "$GH_BIN" "$@"
fi
debug_log "Repository not in ignore list, will use device flow for authentication"

# Get or create user-to-server token via device flow
BOT_TOKEN=$(get_cached_token)
if [ -z "$BOT_TOKEN" ]; then
    echo "[ERROR] Authentication required. Please authorize and try again." >&2
    exit 1
fi

if [ "$DEBUG" = "true" ]; then
    # Verify token type
    if [[ "$BOT_TOKEN" == ghu_* ]]; then
        echo "[INFO] Using user-to-server token (ghu_) - actions will be attributed as 'you (via as-a-bot[bot])'" >&2
    else
        echo "[WARNING] Token doesn't have expected ghu_ prefix - attribution may not work correctly" >&2
    fi
fi

# Execute gh with the user-to-server token
GH_TOKEN="$BOT_TOKEN" exec "$GH_BIN" "$@"