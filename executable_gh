#!/bin/bash

# gh wrapper - Automatically detect AI tools and use bot token attribution via as-a-bot service
# This wrapper intercepts gh CLI calls and exchanges tokens when AI usage is detected

# Configuration
BROKER_URL="${AS_A_BOT_URL:-https://as-bot-worker.minivelos.workers.dev}"
APP_NAME="as-a-bot"
DEBUG="${GH_AI_DEBUG:-false}"

# Function to print debug messages
debug_log() {
    if [ "$DEBUG" = "true" ]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Function to check if a process name contains a pattern (case-insensitive)
process_contains() {
    local pid=$1
    local pattern=$2

    # Get process command and name
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        # Linux
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}

# Generic function to check environment variables for AI detection
check_env_vars() {
    # Phase 1: Environment variable detection
    # Returns space-separated list of detected AI tools
    local detected=""

    # Claude Code detection
    if [ -n "$CLAUDECODE" ] && { [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ]; }; then
        # Additional confidence check: look for Claude processes anywhere in the system
        if pgrep -f "claude" >/dev/null 2>&1; then
            detected="$detected claude"
            debug_log "Detected Claude via environment variable with process confirmation"
        fi
    fi

    # Gemini detection
    if [ -n "$GEMINI_CLI" ]; then
        detected="$detected gemini"
        debug_log "Detected Gemini via environment variable"
    fi

    # Qwen detection
    if [ -n "$QWEN_CODE" ]; then
        detected="$detected qwen"
        debug_log "Detected Qwen via environment variable"
    fi

    # Cursor detection
    if [ -n "$CURSOR_AI" ]; then
        detected="$detected cursor"
        debug_log "Detected Cursor via environment variable"
    fi

    # OpenCode detection
    if [ -n "$OPENCODE_AI" ]; then
        detected="$detected opencode"
        debug_log "Detected OpenCode via environment variable"
    fi

    # Codex CLI detection (environment opt-in)
    if [ -n "$CODEX_CLI" ]; then
        detected="$detected codex"
        debug_log "Detected Codex via environment variable"
    fi

    # Zed detection (environment variables are always present in Zed terminals)
    # We'll rely more on process tree for Zed
    if [ "$TERM_PROGRAM" = "zed" ] || [ "$ZED_TERM" = "true" ]; then
        detected="$detected zed"
        debug_log "Detected Zed via environment variable"
    fi

    # Copilot detection
    if [ "$GITHUB_COPILOT_CLI_MODE" = "true" ]; then
        detected="$detected copilot"
        debug_log "Detected Copilot via environment variable"
    fi

    # Droid detection (Factory AI)
    if [ -n "$DROID_CLI" ]; then
        detected="$detected droid"
        debug_log "Detected Droid via environment variable"
    fi

    # Amp detection (Sourcegraph)
    if [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ]; then
        detected="$detected amp"
        debug_log "Detected Amp via environment variable"
    fi

    # Kimi CLI detection
    if [ -n "$KIMI_CLI" ]; then
        detected="$detected kimi"
        debug_log "Detected Kimi CLI via environment variable"
    fi

    echo "$detected"
}

# Generic function to walk process tree and detect AI tools
check_ps_tree() {
    # Phase 2: Process tree detection
    # Returns space-separated list of detected AI tools
    local detected=""
    local current_pid=$$
    local max_depth=10
    local depth=0

    debug_log "Starting process tree detection from PID $current_pid"

    while [ $depth -lt $max_depth ]; do
        # Get parent PID
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        else
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        fi

        # Check if we've reached the top
        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            debug_log "Reached top of process tree at depth $depth"
            break
        fi

        debug_log "Checking PID $current_pid at depth $depth"

        if process_contains "$current_pid" "claude"; then
            detected="$detected claude"
            debug_log "Detected Claude in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "gemini"; then
            detected="$detected gemini"
            debug_log "Detected Gemini in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "codex"; then
            detected="$detected codex"
            debug_log "Detected Codex in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "qwen"; then
            detected="$detected qwen"
            debug_log "Detected Qwen in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "zed"; then
            detected="$detected zed"
            debug_log "Detected Zed in process tree at depth $depth"
            # Special case: When we find Zed, also check for Claude processes that are siblings
            # (children of the same Zed process) to handle nested AI scenarios
            local zed_children
            zed_children=$(pgrep -P "$current_pid" 2>/dev/null)
            for child_pid in $zed_children; do
                if process_contains "$child_pid" "claude"; then
                    detected="$detected claude"
                    debug_log "Detected nested Claude under Zed at depth $depth"
                    break
                fi
            done
        fi
        if process_contains "$current_pid" "opencode"; then
            detected="$detected opencode"
            debug_log "Detected OpenCode in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "cursor"; then
            detected="$detected cursor"
            debug_log "Detected Cursor in process tree at depth $depth"
        fi
        if process_contains "$current_pid" "kimi"; then
            detected="$detected kimi"
            debug_log "Detected Kimi CLI in process tree at depth $depth"
        fi
        # Droid detection - use word boundary to avoid matching android-studio, etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                debug_log "Detected Droid in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                debug_log "Detected Droid in process tree at depth $depth"
            fi
        fi

        depth=$((depth + 1))
    done

    echo "$detected"
}

# Main AI detection function with proper two-phase approach
detect_ai_tool() {
    debug_log "Starting AI detection"
    
    # Phase 1: Environment variable detection
    local env_detected
    env_detected=$(check_env_vars)

    # Phase 2: Process tree detection
    local ps_detected
    ps_detected=$(check_ps_tree)

    # Combine results and apply priority order
    local all_detected="$env_detected $ps_detected"

    debug_log "Environment detected: '$env_detected'"
    debug_log "Process tree detected: '$ps_detected'"
    debug_log "Combined detected: '$all_detected'"

    # Priority order: Amp > Codex > Claude > Gemini > Qwen > Droid > OpenCode > Cursor > Kimi > Copilot > Zed
    # Zed is last because it often hosts other AI tools
    if [[ "$all_detected" =~ "amp" ]]; then
        debug_log "Final result: amp"
        echo "amp"
    elif [[ "$all_detected" =~ "codex" ]]; then
        debug_log "Final result: codex"
        echo "codex"
    elif [[ "$all_detected" =~ "claude" ]]; then
        debug_log "Final result: claude"
        echo "claude"
    elif [[ "$all_detected" =~ "gemini" ]]; then
        debug_log "Final result: gemini"
        echo "gemini"
    elif [[ "$all_detected" =~ "qwen" ]]; then
        debug_log "Final result: qwen"
        echo "qwen"
    elif [[ "$all_detected" =~ "droid" ]]; then
        debug_log "Final result: droid"
        echo "droid"
    elif [[ "$all_detected" =~ "opencode" ]]; then
        debug_log "Final result: opencode"
        echo "opencode"
    elif [[ "$all_detected" =~ "cursor" ]]; then
        debug_log "Final result: cursor"
        echo "cursor"
    elif [[ "$all_detected" =~ "kimi" ]]; then
        debug_log "Final result: kimi"
        echo "kimi"
    elif [[ "$all_detected" =~ "copilot" ]]; then
        debug_log "Final result: copilot"
        echo "copilot"
    elif [[ "$all_detected" =~ "zed" ]]; then
        debug_log "Final result: zed"
        echo "zed"
    else
        debug_log "Final result: none"
        echo "none"
    fi
}

# Function to find the real gh executable
find_real_gh() {
    # Common locations for gh
    local gh_paths=(
        "/usr/bin/gh"
        "/usr/local/bin/gh"
        "/opt/homebrew/bin/gh"
        "/opt/local/bin/gh"
        "/home/linuxbrew/.linuxbrew/bin/gh"
        "/snap/bin/gh"
    )

    for gh_path in "${gh_paths[@]}"; do
        if [ -x "$gh_path" ]; then
            echo "$gh_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        # Skip our own directory to avoid infinite recursion
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/gh" ]; then
            echo "$dir/gh"
            return
        fi
    done

    echo "gh not found" >&2
    exit 1
}

# Function to parse --repo flag from command arguments
parse_repo_flag() {
    local args=("$@")
    local i=0
    
    while [ $i -lt ${#args[@]} ]; do
        case "${args[i]}" in
            --repo)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
            --repo=*)
                echo "${args[i]#--repo=}"
                return 0
                ;;
            -R)
                if [ $((i + 1)) -lt ${#args[@]} ]; then
                    echo "${args[$((i + 1))]}"
                    return 0
                fi
                ;;
        esac
        i=$((i + 1))
    done
    
    return 1
}

# Function to check if operation is safe (read-only)
is_safe_operation() {
    local cmd="$1"
    local subcommand="$2"
    
    case "$cmd" in
        help|--help|-h|version|--version)
            return 0
            ;;
        auth)
            case "$subcommand" in
                status|login|logout|refresh|setup-git|token)
                    return 0
                    ;;
            esac
            ;;
        repo)
            case "$subcommand" in
                view|list|clone|fork)
                    return 0
                    ;;
            esac
            ;;
        pr)
            case "$subcommand" in
                view|list|diff|checks)
                    return 0
                    ;;
            esac
            ;;
        issue)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        release)
            case "$subcommand" in
                view|list|download)
                    return 0
                    ;;
            esac
            ;;
        run)
            case "$subcommand" in
                view|list|watch)
                    return 0
                    ;;
            esac
            ;;
        workflow)
            case "$subcommand" in
                view|list)
                    return 0
                    ;;
            esac
            ;;
        api)
            # API calls with GET method only
            if [[ "$*" =~ --method[[:space:]]+GET|^GET[[:space:]] ]] || [[ ! "$*" =~ --method ]]; then
                # Default API calls are GET, but be conservative
                case "$subcommand" in
                    user|users/*|rate_limit|repos/*/|orgs/*)
                        return 0
                        ;;
                esac
            fi
            ;;
    esac
    
    return 1
}

# Function to get current repository info
get_repo_info() {
    local repo_spec="$1"  # Optional: explicit repo specification
    local name_with_owner
    
    if [ -n "$repo_spec" ]; then
        # Use explicit repo specification
        debug_log "Using explicit repo specification: $repo_spec"
        name_with_owner="$repo_spec"
    else
        # Try to get repo info from current directory using gh
        debug_log "Attempting to get repo info from current directory"
        name_with_owner=$("$GH_BIN" repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null)
        
        if [ -z "$name_with_owner" ] || [ "$name_with_owner" = "null" ]; then
            debug_log "No repository found in current directory"
            return 1
        fi
    fi
    
    debug_log "Found repository: $name_with_owner"
    
    # Split owner/repo
    if [[ "$name_with_owner" =~ ^([^/]+)/(.+)$ ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        echo "$owner" "$repo"
        debug_log "Parsed owner: $owner, repo: $repo"
        return 0
    fi
    
    debug_log "Could not parse owner/repo from: $name_with_owner"
    return 1
}

# Function to check if a repo should be ignored
should_ignore_repo() {
    local owner=$1
    local repo=$2
    local config_file="$HOME/.config/ai-aligned-gh/ignorerepos"
    
    debug_log "Looking for ignore file at: $config_file"
    
    # If config file doesn't exist, don't ignore
    if [ ! -f "$config_file" ]; then
        debug_log "Ignore file not found"
        return 1
    fi
    
    debug_log "Found ignore file, checking patterns"
    
    # Check each pattern in the ignore file
    while IFS= read -r pattern || [ -n "$pattern" ]; do
        # Skip empty lines and comments
        if [[ -z "$pattern" ]] || [[ "$pattern" =~ ^[[:space:]]*# ]]; then
            continue
        fi
        
        # Trim whitespace
        pattern=$(echo "$pattern" | xargs)
        
        debug_log "Checking pattern: '$pattern' against '$owner/$repo'"
        
        # Check if pattern matches owner/repo exactly
        if [[ "$owner/$repo" == "$pattern" ]]; then
            debug_log "Repository $owner/$repo matches ignore pattern: $pattern"
            return 0
        fi
        
        # Check if pattern is owner/* (matches all repos in org)
        if [[ "$pattern" == *"/*" ]] && [[ "$owner" == "${pattern%/*}" ]]; then
            debug_log "Repository $owner/$repo matches org pattern: $pattern"
            return 0
        fi
    done < "$config_file"
    
    return 1
}

# Function to start device flow authentication
start_device_flow() {
    local scopes="${1:-repo}"
    
    debug_log "Starting device flow authentication with scopes: $scopes"
    
    local response
    response=$(curl -sS -X POST "${BROKER_URL}/user-token/start" \
        -H "Content-Type: application/json" \
        -d "{\"scopes\":\"${scopes}\"}" 2>/dev/null)
    
    if [ -z "$response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    echo "$response"
    return 0
}

# Function to poll for device flow token in background
poll_for_token_background() {
    local device_code=$1
    local state_file=$2
    local interval=${3:-5}
    local max_time=${4:-300}  # Max 5 minutes by default
    
    local start_time
    start_time=$(date +%s)
    
    while true; do
        local current_time
        current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [ "$elapsed" -gt "$max_time" ]; then
            echo "expired" > "${state_file}.status"
            break
        fi
        
        local response
        response=$(curl -sS -X POST "${BROKER_URL}/user-token/poll" \
            -H "Content-Type: application/json" \
            -d "{\"device_code\":\"${device_code}\"}" 2>/dev/null)
        
        local access_token
        access_token=$(echo "$response" | jq -r '.access_token' 2>/dev/null)
        
        if [ -n "$access_token" ] && [ "$access_token" != "null" ]; then
            # Save the token to cache
            echo "$access_token" > "$HOME/.cache/ai-aligned-gh/token"
            chmod 600 "$HOME/.cache/ai-aligned-gh/token"
            echo "completed" > "${state_file}.status"
            rm -f "$state_file"
            break
        fi
        
        local error
        error=$(echo "$response" | jq -r '.error' 2>/dev/null)
        
        if [ "$error" = "authorization_pending" ] || [ "$error" = "server_error" ]; then
            sleep "$interval"
        elif [ "$error" = "slow_down" ]; then
            interval=$((interval + 5))
            sleep "$interval"
        elif [ -n "$error" ] && [ "$error" != "null" ]; then
            echo "failed: $error" > "${state_file}.status"
            break
        fi
    done
}

# Function to get or create cached token
get_cached_token() {
    local cache_dir="$HOME/.cache/ai-aligned-gh"
    local state_dir="$HOME/.config/ai-aligned-gh/auth"
    local cache_file="$cache_dir/token"
    local state_file="$state_dir/device_flow.json"
    
    # Create directories if they don't exist
    mkdir -p "$cache_dir" "$state_dir"
    
    # Check if cached token exists and is still valid
    if [ -f "$cache_file" ]; then
        local cached_token
        cached_token=$(cat "$cache_file")
        
        # Verify token is still valid and check its type
        local rate_limit
        
        if GH_TOKEN="$cached_token" "$GH_BIN" api user >/dev/null 2>&1; then
            # Check if this is a user-to-server token (ghu_ prefix)
            if [[ "$cached_token" == ghu_* ]]; then
                debug_log "Using valid user-to-server token (ghu_ prefix)"
                
                # Optionally check rate limit to confirm it's a proper GitHub App token
                if [ "$DEBUG" = "true" ]; then
                    rate_limit=$(GH_TOKEN="$cached_token" "$GH_BIN" api rate_limit --jq '.rate.limit' 2>/dev/null)
                    debug_log "Token rate limit: $rate_limit (15000=GitHub App user token, 5000=OAuth token)"
                fi
            else
                debug_log "WARNING: Token doesn't have ghu_ prefix, may not have app attribution"
            fi
            
            echo "$cached_token"
            return 0
        else
            debug_log "Cached token is invalid, removing it"
            rm -f "$cache_file"
        fi
    fi
    
    # Check if there's an in-progress device flow
    if [ -f "$state_file" ]; then
        local state_age=$(($(date +%s) - $(stat -f %m "$state_file" 2>/dev/null || stat -c %Y "$state_file" 2>/dev/null)))
        
        # If state file is less than 15 minutes old
        if [ $state_age -lt 900 ]; then
            debug_log "Found recent device flow state (${state_age}s old)"
            
            # Check if there's a status file indicating completion
            if [ -f "${state_file}.status" ]; then
                local status
                status=$(cat "${state_file}.status")
                
                if [ "$status" = "completed" ]; then
                    # Token should have been saved, try again
                    rm -f "${state_file}.status"
                    if [ -f "$cache_file" ]; then
                        cached_token=$(cat "$cache_file")
                        echo "$cached_token"
                        return 0
                    fi
                elif [[ "$status" == "failed:"* ]]; then
                    echo "[ERROR] Previous authentication failed: ${status#failed: }" >&2
                    rm -f "$state_file" "${state_file}.status"
                elif [ "$status" = "expired" ]; then
                    echo "[ERROR] Previous authentication expired" >&2
                    rm -f "$state_file" "${state_file}.status"
                fi
            else
                # Still in progress, show the existing code
                local user_code verification_uri
                user_code=$(jq -r '.user_code' "$state_file" 2>/dev/null)
                verification_uri=$(jq -r '.verification_uri' "$state_file" 2>/dev/null)
                
                if [ -n "$user_code" ] && [ -n "$verification_uri" ]; then
                    echo "" >&2
                    echo "=================================================================" >&2
                    echo "  GitHub App Authentication Already In Progress" >&2
                    echo "=================================================================" >&2
                    echo "" >&2
                    echo "  AI tool detected: $AI_TOOL" >&2
                    echo "" >&2
                    echo "  Please complete the authorization:" >&2
                    echo "" >&2
                    echo "  For humans:" >&2
                    echo "  1. Visit: $verification_uri" >&2
                    echo "  2. Enter code: $user_code" >&2
                    echo "" >&2
                    echo "  For AI agents - run these commands:" >&2
                    echo "  echo '$user_code' | pbcopy" >&2
                    echo "  open '$verification_uri'" >&2
                    echo "" >&2
                    echo "  Authentication will complete in the background." >&2
                    echo "  Try your command again in a few seconds." >&2
                    echo "" >&2
                    return 1
                fi
            fi
        else
            debug_log "Device flow state is too old (${state_age}s), removing"
            rm -f "$state_file" "${state_file}.status"
        fi
    fi
    
    # No valid cached token or in-progress flow, start new auth flow
    debug_log "Starting new authentication flow"
    
    # Use device flow for CLI (doesn't require browser redirect)
    debug_log "Starting device flow for CLI authentication"
    flow_response=$(start_device_flow "")
    
    if [ -z "$flow_response" ]; then
        debug_log "Failed to start device flow"
        return 1
    fi
    
    local device_code user_code verification_uri expires_in interval
    device_code=$(echo "$flow_response" | jq -r '.device_code' 2>/dev/null)
    user_code=$(echo "$flow_response" | jq -r '.user_code' 2>/dev/null)
    verification_uri=$(echo "$flow_response" | jq -r '.verification_uri' 2>/dev/null)
    expires_in=$(echo "$flow_response" | jq -r '.expires_in' 2>/dev/null)
    interval=$(echo "$flow_response" | jq -r '.interval' 2>/dev/null)
    
    if [ -z "$device_code" ] || [ -z "$user_code" ] || [ -z "$verification_uri" ]; then
        debug_log "Invalid device flow response"
        return 1
    fi
    
    # Save state to file
    echo "$flow_response" > "$state_file"
    chmod 600 "$state_file"
    
    # Start background polling process (properly detached)
    debug_log "Starting background polling process"
    
    # Export necessary variables and functions for the background process
    export -f poll_for_token_background
    export BROKER_URL
    export HOME
    
    # Start detached background process that will survive parent exit
    nohup bash -c "poll_for_token_background '$device_code' '$state_file' '${interval:-5}' '${expires_in:-900}'" </dev/null >/dev/null 2>&1 &
    
    # Disown the process so it's not killed when this script exits
    disown -h %1
    
    # Show user instructions
    echo "" >&2
    echo "=================================================================" >&2
    echo "  GitHub App Authentication Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  Please authorize the '$APP_NAME' GitHub App:" >&2
    echo "" >&2
    echo "  For humans:" >&2
    echo "  1. Visit: $verification_uri" >&2
    echo "  2. Enter code: $user_code" >&2
    echo "" >&2
    echo "  For AI agents - run these commands:" >&2
    echo "  echo '$user_code' | pbcopy" >&2
    echo "  open '$verification_uri'" >&2
    echo "" >&2
    echo "  Authentication will complete in the background." >&2
    echo "  Try your command again after authorizing." >&2
    echo "" >&2
    
    return 1
}

# Main script
GH_BIN=$(find_real_gh)
debug_log "Found gh at: $GH_BIN"

# Detect if an AI tool is running
AI_TOOL=$(detect_ai_tool)

if [ "$AI_TOOL" = "none" ]; then
    # No AI detected, pass through to regular gh
    debug_log "No AI detected, passing through to gh"
    exec "$GH_BIN" "$@"
fi

# AI detected - show info if in debug mode
if [ "$DEBUG" = "true" ]; then
    echo "[INFO] AI detected: $AI_TOOL - checking for bot token exchange..." >&2
fi

# Check if this is a safe operation that doesn't need token exchange
if is_safe_operation "$@"; then
    debug_log "Safe operation, skipping token exchange"
    exec "$GH_BIN" "$@"
fi

# Parse --repo flag if present
REPO_SPEC=""
if REPO_SPEC=$(parse_repo_flag "$@"); then
    debug_log "Found --repo flag: $REPO_SPEC"
fi

# Try to get repository info (either from --repo flag or current directory)
if ! read -r owner repo < <(get_repo_info "$REPO_SPEC"); then
    # For unsafe operations, we MUST have repository info to proceed with AI attribution
    echo "" >&2
    echo "=================================================================" >&2
    echo "  Repository Required for AI-Aligned Operations" >&2
    echo "=================================================================" >&2
    echo "" >&2
    echo "  AI tool detected: $AI_TOOL" >&2
    echo "" >&2
    echo "  This operation requires repository context for proper AI attribution." >&2
    echo "" >&2
    echo "  Please either:" >&2
    echo "  1. Run this command from within a GitHub repository directory, or" >&2
    echo "  2. Use the --repo flag to specify the repository: --repo owner/repo" >&2
    echo "" >&2
    echo "  Refusing to proceed with user token to prevent misattribution." >&2
    echo "" >&2
    exit 1
fi

# Check if this repo should be ignored
debug_log "Checking if $owner/$repo should be ignored"
if should_ignore_repo "$owner" "$repo"; then
    debug_log "Repository is in ignore list, proceeding without bot attribution"
    exec "$GH_BIN" "$@"
fi
debug_log "Repository not in ignore list, will use device flow for authentication"

# Get or create user-to-server token via device flow
BOT_TOKEN=$(get_cached_token)
if [ -z "$BOT_TOKEN" ]; then
    echo "[ERROR] Authentication required. Please authorize and try again." >&2
    exit 1
fi

if [ "$DEBUG" = "true" ]; then
    # Verify token type
    if [[ "$BOT_TOKEN" == ghu_* ]]; then
        echo "[INFO] Using user-to-server token (ghu_) - actions will be attributed as 'you (via as-a-bot[bot])'" >&2
    else
        echo "[WARNING] Token doesn't have expected ghu_ prefix - attribution may not work correctly" >&2
    fi
fi

# Execute gh with the user-to-server token and handle GitHub App installation errors
execute_gh_with_error_handling() {
    local stderr_file
    local exit_code
    
    # Create a temporary file for stderr
    stderr_file=$(mktemp)
    
    # Execute gh with stderr redirected to temp file
    GH_TOKEN="$BOT_TOKEN" "$GH_BIN" "$@" 2>"$stderr_file"
    exit_code=$?
    
    # If command failed, check for specific GitHub App errors
    if [ $exit_code -ne 0 ]; then
        local stderr_content
        stderr_content=$(cat "$stderr_file")
        
        debug_log "gh command failed with exit code $exit_code"
        debug_log "stderr: $stderr_content"
        
        # Check for GitHub App not installed error
        if echo "$stderr_content" | grep -qi "Resource not accessible by integration"; then
            echo "" >&2
            echo "=================================================================" >&2
            echo "  GitHub App Installation Required" >&2
            echo "=================================================================" >&2
            echo "" >&2
            echo "  The 'as-a-bot' GitHub App is not installed in this repository." >&2
            echo "" >&2
            echo "  To enable AI-aligned operations, please:" >&2
            echo "" >&2
            echo "  1. Visit: https://github.com/apps/as-a-bot" >&2
            echo "  2. Click 'Install' or 'Configure'" >&2
            echo "  3. Select the repository: $owner/$repo" >&2
            echo "  4. Grant the required permissions" >&2
            echo "" >&2
            echo "  After installation, try your command again." >&2
            echo "" >&2
            echo "  Original error:" >&2
            echo "  $stderr_content" >&2
            echo "" >&2
            rm -f "$stderr_file"
            exit 1
        fi
        
        # For other errors, just show the original error and exit
        cat "$stderr_file" >&2
        rm -f "$stderr_file"
        exit $exit_code
    fi
    
    # Clean up temp file on success
    rm -f "$stderr_file"
    exit 0
}

execute_gh_with_error_handling "$@"
